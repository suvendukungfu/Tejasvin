import {
  BufferAttribute,
  InstancedMesh,
  Line3,
  Matrix4,
  Mesh,
  Object3D,
  Plane,
  Quaternion,
  Ray,
  Raycaster,
  Sphere,
  SphereGeometry,
  Triangle,
  Vector2,
  Vector3
} from "./chunk-53NBYJ6A.js";
import {
  __publicField
} from "./chunk-EWTE5DHJ.js";

// node_modules/@pmndrs/pointer-events/dist/html-event.js
var HtmlEvent = class {
  constructor(nativeEvent) {
    __publicField(this, "nativeEvent");
    __publicField(this, "NONE", 0);
    __publicField(this, "CAPTURING_PHASE", 1);
    __publicField(this, "AT_TARGET", 2);
    __publicField(this, "BUBBLING_PHASE", 3);
    __publicField(this, "relatedTarget", null);
    this.nativeEvent = nativeEvent;
  }
  get altKey() {
    return this.getFromNative("altKey", false);
  }
  get button() {
    return this.getFromNative("button", 0);
  }
  get buttons() {
    return this.getFromNative("buttons", 0);
  }
  get clientX() {
    return this.getFromNative("clientX", 0);
  }
  get clientY() {
    return this.getFromNative("clientY", 0);
  }
  get ctrlKey() {
    return this.getFromNative("ctrlKey", false);
  }
  get layerX() {
    return this.getFromNative("layerX", 0);
  }
  get layerY() {
    return this.getFromNative("layerY", 0);
  }
  get metaKey() {
    return this.getFromNative("metaKey", false);
  }
  get movementX() {
    return this.getFromNative("movementX", 0);
  }
  get movementY() {
    return this.getFromNative("movementY", 0);
  }
  get offsetX() {
    return this.getFromNative("offsetX", 0);
  }
  get offsetY() {
    return this.getFromNative("offsetY", 0);
  }
  get pageX() {
    return this.getFromNative("pageX", 0);
  }
  get pageY() {
    return this.getFromNative("pageY", 0);
  }
  get screenX() {
    return this.getFromNative("screenX", 0);
  }
  get screenY() {
    return this.getFromNative("screenY", 0);
  }
  get shiftKey() {
    return this.getFromNative("shiftKey", false);
  }
  get x() {
    return this.getFromNative("x", 0);
  }
  get y() {
    return this.getFromNative("y", 0);
  }
  get detail() {
    return this.getFromNative("detail", 0);
  }
  get view() {
    return this.getFromNative("view", null);
  }
  get which() {
    return this.getFromNative("which", 0);
  }
  get cancelBubble() {
    return this.getFromNative("cancelBubble", false);
  }
  get composed() {
    return this.getFromNative("composed", false);
  }
  get eventPhase() {
    return this.getFromNative("eventPhase", 0);
  }
  get isTrusted() {
    return this.getFromNative("isTrusted", false);
  }
  get returnValue() {
    return this.getFromNative("returnValue", false);
  }
  get timeStamp() {
    return this.getFromNative("timeStamp", 0);
  }
  get cancelable() {
    return this.getFromNative("cancelable", false);
  }
  get defaultPrevented() {
    return this.getFromNative("defaultPrevented", false);
  }
  getFromNative(key, defaultValue) {
    if (key in this.nativeEvent) {
      return this.nativeEvent[key];
    }
    return defaultValue;
  }
};

// node_modules/@pmndrs/pointer-events/dist/event.js
var helperVector = new Vector3();
var PointerEvent = class _PointerEvent extends HtmlEvent {
  constructor(type, bubbles, nativeEvent, internalPointer, intersection, camera, currentObject = intersection.object, object = currentObject, propagationState = {
    stopped: !bubbles,
    stoppedImmediate: false
  }) {
    super(nativeEvent);
    __publicField(this, "type");
    __publicField(this, "bubbles");
    __publicField(this, "internalPointer");
    __publicField(this, "intersection");
    __publicField(this, "camera");
    __publicField(this, "currentObject");
    __publicField(this, "object");
    __publicField(this, "propagationState");
    __publicField(this, "_pointer");
    __publicField(this, "_ray");
    __publicField(this, "_intersections", []);
    __publicField(this, "_unprojectedPoint");
    this.type = type;
    this.bubbles = bubbles;
    this.internalPointer = internalPointer;
    this.intersection = intersection;
    this.camera = camera;
    this.currentObject = currentObject;
    this.object = object;
    this.propagationState = propagationState;
  }
  //--- pointer events data
  get pointerId() {
    return this.internalPointer.id;
  }
  get pointerType() {
    return this.internalPointer.type;
  }
  get pointerState() {
    return this.internalPointer.state;
  }
  //--- intersection data
  get distance() {
    return this.intersection.distance;
  }
  get distanceToRay() {
    return this.intersection.distanceToRay;
  }
  get point() {
    return this.intersection.point;
  }
  get index() {
    return this.intersection.index;
  }
  get face() {
    return this.intersection.face;
  }
  get faceIndex() {
    return this.intersection.faceIndex;
  }
  get uv() {
    return this.intersection.uv;
  }
  get uv1() {
    return this.intersection.uv1;
  }
  get normal() {
    return this.intersection.normal;
  }
  get instanceId() {
    return this.intersection.instanceId;
  }
  get pointOnLine() {
    return this.intersection.pointOnLine;
  }
  get batchId() {
    return this.intersection.batchId;
  }
  get pointerPosition() {
    return this.intersection.pointerPosition;
  }
  get pointerQuaternion() {
    return this.intersection.pointerQuaternion;
  }
  get pointOnFace() {
    return this.intersection.pointOnFace;
  }
  get localPoint() {
    return this.intersection.localPoint;
  }
  get details() {
    return this.intersection.details;
  }
  /** same as object */
  get target() {
    return this.object;
  }
  /** same as currentObject */
  get currentTarget() {
    return this.currentObject;
  }
  /** same as currentObject */
  get eventObject() {
    return this.currentObject;
  }
  /** same as object */
  get srcElement() {
    return this.currentObject;
  }
  get pointer() {
    if (this._pointer == null) {
      helperVector.copy(this.intersection.point).project(this.camera);
      this._pointer = new Vector2(helperVector.x, helperVector.y);
    }
    return this._pointer;
  }
  get ray() {
    if (this._ray != null) {
      return this._ray;
    }
    switch (this.intersection.details.type) {
      case "screen-ray":
      case "ray":
      case "sphere":
        return this._ray = new Ray(this.intersection.pointerPosition, new Vector3(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion));
      case "lines":
        return this._ray = new Ray(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize());
    }
  }
  get intersections() {
    if (this._intersections == null) {
      this._intersections = [{ ...this.intersection, eventObject: this.currentObject }];
    }
    return this._intersections;
  }
  get unprojectedPoint() {
    if (this._unprojectedPoint == null) {
      const p = this.pointer;
      this._unprojectedPoint = new Vector3(p.x, p.y, 0).unproject(this.camera);
    }
    return this._unprojectedPoint;
  }
  get stopped() {
    return this.propagationState.stoppedImmediate || this.propagationState.stopped;
  }
  get stoppedImmediate() {
    return this.propagationState.stoppedImmediate;
  }
  get delta() {
    throw new Error(`not supported`);
  }
  stopPropagation() {
    this.propagationState.stopped = true;
  }
  stopImmediatePropagation() {
    this.propagationState.stoppedImmediate = true;
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    return new _PointerEvent(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target, this.propagationState);
  }
};
var WheelEvent = class _WheelEvent extends PointerEvent {
  get deltaX() {
    return this.nativeEvent.deltaX;
  }
  get deltaY() {
    return this.nativeEvent.deltaY;
  }
  get deltaZ() {
    return this.nativeEvent.deltaZ;
  }
  constructor(nativeEvent, pointer, intersection, camera, currentObject, object) {
    super("wheel", true, nativeEvent, pointer, intersection, camera, currentObject, object);
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    return new _WheelEvent(this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target);
  }
};
function emitPointerEvent(event) {
  emitPointerEventRec(event, event.currentObject);
}
function emitPointerEventRec(baseEvent, currentObject) {
  if (currentObject == null) {
    return;
  }
  const listeners = getObjectListeners(currentObject, baseEvent.type);
  if (listeners != null && listeners.length > 0) {
    const event = baseEvent.retarget(currentObject);
    const length = listeners.length;
    for (let i = 0; i < length && !event.stoppedImmediate; i++) {
      listeners[i](event);
    }
  }
  if (baseEvent.stopped) {
    return;
  }
  emitPointerEventRec(baseEvent, currentObject.parent);
}
var r3fEventToHandlerMap = {
  click: "onClick",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick",
  pointercancel: "onPointerCancel",
  pointerdown: "onPointerDown",
  pointerenter: "onPointerEnter",
  pointerleave: "onPointerLeave",
  pointermove: "onPointerMove",
  pointerout: "onPointerOut",
  pointerover: "onPointerOver",
  pointerup: "onPointerUp",
  wheel: "onWheel"
};
var listenerNames = Object.keys(r3fEventToHandlerMap);
function getObjectListeners(object, forEvent) {
  var _a;
  if (object._listeners != null && forEvent in object._listeners) {
    return object._listeners[forEvent];
  }
  let handler;
  if (object.isVoidObject && forEvent === "click" && ((_a = object.parent) == null ? void 0 : _a.__r3f) != null) {
    handler = object.parent.__r3f.root.getState().onPointerMissed;
  }
  if (object.__r3f != null) {
    handler = object.__r3f.handlers[r3fEventToHandlerMap[forEvent]];
  }
  if (handler == null) {
    return void 0;
  }
  return [handler];
}

// node_modules/@pmndrs/pointer-events/dist/intersections/intersector.js
var VoidObjectRadius = 1e10;
var VoidObjectGeometry = new SphereGeometry(VoidObjectRadius);
var sceneVoidObjectMap = /* @__PURE__ */ new Map();
function getVoidObject(scene) {
  let entry = sceneVoidObjectMap.get(scene);
  if (entry == null) {
    entry = new Mesh(VoidObjectGeometry);
    entry.isVoidObject = true;
    entry.parent = scene;
    entry.pointerEventsOrder = -Infinity;
    sceneVoidObjectMap.set(scene, entry);
  }
  return entry;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/utils.js
function computeIntersectionWorldPlane(target, intersection, objectMatrixWorld) {
  var _a;
  const normal = intersection.normal ?? ((_a = intersection.face) == null ? void 0 : _a.normal);
  if (normal == null) {
    return false;
  }
  target.setFromNormalAndCoplanarPoint(normal, intersection.localPoint);
  target.applyMatrix4(objectMatrixWorld);
  return true;
}
function isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {
  if (pointerEvents === "none") {
    return false;
  }
  if (pointerEvents === "listener" && !hasListener) {
    return false;
  }
  if (pointerEventsType === "all") {
    return true;
  }
  if (typeof pointerEventsType === "function") {
    return ({ id, type, state }) => pointerEventsType(id, type, state);
  }
  let value;
  let invert;
  if ("deny" in pointerEventsType) {
    invert = true;
    value = pointerEventsType.deny;
  } else {
    invert = false;
    value = pointerEventsType.allow;
  }
  if (Array.isArray(value)) {
    return (pointer) => invertIf(value.includes(pointer.type), invert);
  }
  return (pointer) => invertIf(value === pointer.type, invert);
}
function invertIf(toInvert, ifIsTrue) {
  return ifIsTrue ? !toInvert : toInvert;
}
function intersectPointerEventTargets(type, object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {
  const hasListener = parentHasListener || hasObjectListeners(type, object);
  const pointerEvents = object.pointerEvents ?? parentPointerEvents;
  const pointerEventsOrDefault = pointerEvents ?? object.defaultPointerEvents ?? "listener";
  const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? "all";
  const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder ?? 0;
  const isAllowed = isPointerEventsAllowed(hasListener, pointerEventsOrDefault, pointerEventsType);
  const length = pointers.length;
  if (length === 1) {
    if (isAllowed === true || typeof isAllowed === "function" && isAllowed(pointers[0])) {
      filterAndInteresct(pointers[0], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  } else if (isAllowed === true) {
    for (let i = 0; i < length; i++) {
      filterAndInteresct(pointers[i], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  } else if (typeof isAllowed === "function") {
    for (let i = 0; i < length; i++) {
      const pointer = pointers[i];
      if (!isAllowed(pointer)) {
        continue;
      }
      filterAndInteresct(pointer, object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  }
  if (object.children.length === 0 || object.intersectChildren === false) {
    return;
  }
  const descendants = object.interactableDescendants ?? object.children;
  const descendantsLength = descendants.length;
  for (let i = 0; i < descendantsLength; i++) {
    intersectPointerEventTargets(type, descendants[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);
  }
}
function hasObjectListeners(type, object) {
  var _a;
  if (object.ancestorsHaveListeners) {
    return true;
  }
  if (type === "pointer" && object.ancestorsHavePointerListeners) {
    return true;
  }
  if (type === "wheel" && object.ancestorsHaveWheelListeners) {
    return true;
  }
  if (object.__r3f != null && ((_a = object.__r3f) == null ? void 0 : _a.eventCount) > 0) {
    if (type === "wheel" && object.__r3f["handlers"]["onWheel"] != null) {
      return true;
    }
    if (type === "pointer" && Object.keys(object.__r3f["handlers"]).some((key) => key != "onWheel")) {
      return true;
    }
  }
  if (object._listeners == null) {
    return false;
  }
  if (type === "wheel") {
    const wheelListeners = object._listeners.wheel;
    return wheelListeners != null && wheelListeners.length > 0;
  }
  const entries = Object.entries(object._listeners);
  const length = entries.length;
  for (let i = 0; i < length; i++) {
    const entry = entries[i];
    if (entry[0] === "wheel") {
      continue;
    }
    if (!listenerNames.includes(entry[0])) {
      continue;
    }
    if (entry[1] != null && entry[1].length > 0) {
      return true;
    }
  }
  return false;
}
function filterAndInteresct({ intersector, options }, object, pointerEvents, pointerEventsType, pointerEventsOrder) {
  var _a;
  if (((_a = options.filter) == null ? void 0 : _a.call(options, object, pointerEvents, pointerEventsType, pointerEventsOrder)) === false) {
    return;
  }
  intersector.executeIntersection(object, pointerEventsOrder);
}
function getDominantIntersectionIndex(intersections, pointerEventsOrders, { customSort: compare = defaultSort } = {}, filter) {
  let intersection = void 0;
  let pointerEventsOrder = void 0;
  let index = void 0;
  const length = intersections.length;
  for (let i = 0; i < length; i++) {
    const newIntersection = intersections[i];
    if ((filter == null ? void 0 : filter(newIntersection)) === false) {
      continue;
    }
    const newPointerEventsOrder = pointerEventsOrders == null ? void 0 : pointerEventsOrders[i];
    if (intersection == null || compare(newIntersection, newPointerEventsOrder, intersection, pointerEventsOrder) < 0) {
      index = i;
      intersection = newIntersection;
      pointerEventsOrder = newPointerEventsOrder;
    }
  }
  return index;
}
function defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {
  if (pointerEventsOrder1 != pointerEventsOrder2) {
    return pointerEventsOrder2 - pointerEventsOrder1;
  }
  return i1.distance - i2.distance;
}
var VoidObjectDistance = 1e7;
function voidObjectIntersectionFromRay(scene, ray, getDetails, pointerPosition, pointerQuaternion, addToDistance = 0) {
  const point = ray.direction.clone().multiplyScalar(VoidObjectDistance);
  const distanceOnRay = VoidObjectDistance;
  return {
    distance: distanceOnRay + addToDistance,
    object: getVoidObject(scene),
    point,
    normal: ray.origin.clone().sub(point).normalize(),
    details: getDetails(point, distanceOnRay),
    pointerPosition,
    pointerQuaternion,
    pointOnFace: point,
    localPoint: point
  };
}
function pushTimes(target, value, times) {
  while (times > 0) {
    target.push(value);
    --times;
  }
}

// node_modules/@pmndrs/pointer-events/dist/pointer.js
var buttonsDownTimeKey = Symbol("buttonsDownTime");
var buttonsClickTimeKey = Symbol("buttonsClickTime");
globalThis.pointerEventspointerMap ?? (globalThis.pointerEventspointerMap = /* @__PURE__ */ new Map());
Object3D.prototype.setPointerCapture = function(pointerId) {
  var _a;
  (_a = getPointerById(pointerId)) == null ? void 0 : _a.setCapture(this);
};
Object3D.prototype.releasePointerCapture = function(pointerId) {
  const pointer = getPointerById(pointerId);
  if (pointer == null || !pointer.hasCaptured(this)) {
    return;
  }
  pointer.setCapture(void 0);
};
Object3D.prototype.hasPointerCapture = function(pointerId) {
  var _a;
  return ((_a = getPointerById(pointerId)) == null ? void 0 : _a.hasCaptured(this)) ?? false;
};
function getPointerById(pointerId) {
  var _a;
  return (_a = globalThis.pointerEventspointerMap) == null ? void 0 : _a.get(pointerId);
}
var Pointer = class {
  constructor(id, type, state, intersector, getCamera, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {
    __publicField(this, "id");
    __publicField(this, "type");
    __publicField(this, "state");
    __publicField(this, "intersector");
    __publicField(this, "getCamera");
    __publicField(this, "onMoveCommited");
    __publicField(this, "parentSetPointerCapture");
    __publicField(this, "parentReleasePointerCapture");
    __publicField(this, "options");
    //state
    __publicField(this, "prevIntersection");
    __publicField(this, "intersection");
    __publicField(this, "prevEnabled", true);
    __publicField(this, "enabled", true);
    __publicField(this, "wheelIntersection");
    //derived state
    /**
     * ordered leaf -> root (bottom -> top)
     */
    __publicField(this, "pointerEntered", []);
    __publicField(this, "pointerEnteredHelper", []);
    __publicField(this, "pointerCapture");
    __publicField(this, "buttonsDownTime", /* @__PURE__ */ new Map());
    __publicField(this, "buttonsDown", /* @__PURE__ */ new Set());
    //to handle interaction before first move (after exit)
    __publicField(this, "wasMoved", false);
    __publicField(this, "onFirstMove", []);
    var _a;
    this.id = id;
    this.type = type;
    this.state = state;
    this.intersector = intersector;
    this.getCamera = getCamera;
    this.onMoveCommited = onMoveCommited;
    this.parentSetPointerCapture = parentSetPointerCapture;
    this.parentReleasePointerCapture = parentReleasePointerCapture;
    this.options = options;
    (_a = globalThis.pointerEventspointerMap) == null ? void 0 : _a.set(id, this);
  }
  getPointerCapture() {
    return this.pointerCapture;
  }
  hasCaptured(object) {
    var _a;
    return ((_a = this.pointerCapture) == null ? void 0 : _a.object) === object;
  }
  setCapture(object) {
    var _a, _b, _c;
    if (((_a = this.pointerCapture) == null ? void 0 : _a.object) === object) {
      return;
    }
    if (this.pointerCapture != null) {
      (_b = this.parentReleasePointerCapture) == null ? void 0 : _b.call(this);
      this.pointerCapture = void 0;
    }
    if (object != null && this.intersection != null) {
      this.pointerCapture = { object, intersection: this.intersection };
      (_c = this.parentSetPointerCapture) == null ? void 0 : _c.call(this);
    }
  }
  getButtonsDown() {
    return this.buttonsDown;
  }
  /**
   * @returns undefined if no intersection was executed yet
   */
  getIntersection() {
    return this.intersection;
  }
  getEnabled() {
    return this.enabled;
  }
  setEnabled(enabled, nativeEvent, commit = true) {
    var _a;
    if (this.enabled === enabled) {
      return;
    }
    if (!enabled && this.pointerCapture != null) {
      (_a = this.parentReleasePointerCapture) == null ? void 0 : _a.call(this);
      this.pointerCapture = void 0;
    }
    this.enabled = enabled;
    if (commit) {
      this.commit(nativeEvent, false);
    }
  }
  computeIntersection(type, scene, nativeEvent) {
    if (this.pointerCapture != null) {
      return this.intersector.intersectPointerCapture(this.pointerCapture, nativeEvent);
    }
    this.intersector.startIntersection(nativeEvent);
    intersectPointerEventTargets(type, scene, [this]);
    return this.intersector.finalizeIntersection(scene);
  }
  setIntersection(intersection) {
    this.intersection = intersection;
  }
  commit(nativeEvent, emitMove) {
    var _a;
    const camera = this.getCamera();
    const prevIntersection = this.prevEnabled ? this.prevIntersection : void 0;
    const intersection = this.enabled ? this.intersection : void 0;
    if (prevIntersection != null && prevIntersection.object != (intersection == null ? void 0 : intersection.object)) {
      emitPointerEvent(new PointerEvent("pointerout", true, nativeEvent, this, prevIntersection, camera));
    }
    const pointerLeft = this.pointerEntered;
    this.pointerEntered = [];
    this.pointerEnteredHelper.length = 0;
    computeEnterLeave(intersection == null ? void 0 : intersection.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);
    const length = pointerLeft.length;
    for (let i = 0; i < length; i++) {
      const object = pointerLeft[i];
      emitPointerEvent(new PointerEvent("pointerleave", false, nativeEvent, this, prevIntersection, camera, object));
    }
    if (intersection != null && (prevIntersection == null ? void 0 : prevIntersection.object) != intersection.object) {
      emitPointerEvent(new PointerEvent("pointerover", true, nativeEvent, this, intersection, camera));
    }
    for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {
      const object = this.pointerEnteredHelper[i];
      emitPointerEvent(new PointerEvent("pointerenter", false, nativeEvent, this, intersection, camera, object));
    }
    if (emitMove && intersection != null) {
      emitPointerEvent(new PointerEvent("pointermove", true, nativeEvent, this, intersection, camera));
    }
    this.prevIntersection = this.intersection;
    this.prevEnabled = this.enabled;
    if (!this.wasMoved && this.intersector.isReady()) {
      this.wasMoved = true;
      const length2 = this.onFirstMove.length;
      for (let i = 0; i < length2; i++) {
        this.onFirstMove[i](camera);
      }
      this.onFirstMove.length = 0;
    }
    (_a = this.onMoveCommited) == null ? void 0 : _a.call(this, this);
  }
  /**
   * computes and commits a move
   */
  move(scene, nativeEvent) {
    this.intersection = this.computeIntersection("pointer", scene, nativeEvent);
    this.commit(nativeEvent, true);
  }
  /**
   * computes and commits the pointer if a move has not yet occured
   */
  over(scene, nativeEvent) {
    if (!this.wasMoved) {
      this.intersection = this.computeIntersection("pointer", scene, nativeEvent);
      this.commit(nativeEvent, false);
    }
  }
  /**
   * emits a move without (re-)computing the intersection
   * just emitting a move event to the current intersection
   */
  emitMove(nativeEvent) {
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointermove", true, nativeEvent, this, this.intersection, this.getCamera()));
  }
  down(nativeEvent) {
    this.buttonsDown.add(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.down.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointerdown", true, nativeEvent, this, this.intersection, this.getCamera()));
    const { object } = this.intersection;
    object[buttonsDownTimeKey] ?? (object[buttonsDownTimeKey] = /* @__PURE__ */ new Map());
    object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);
    this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);
  }
  up(nativeEvent) {
    this.buttonsDown.delete(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.up.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    const { clickThesholdMs, contextMenuButton = 2, dblClickThresholdMs = 500, clickThresholdMs = clickThesholdMs ?? 300 } = this.options;
    this.pointerCapture = void 0;
    const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThresholdMs);
    const camera = this.getCamera();
    if (isClicked && nativeEvent.button === contextMenuButton) {
      emitPointerEvent(new PointerEvent("contextmenu", true, nativeEvent, this, this.intersection, camera));
    }
    emitPointerEvent(new PointerEvent("pointerup", true, nativeEvent, this, this.intersection, camera));
    if (!isClicked || nativeEvent.button === contextMenuButton) {
      return;
    }
    emitPointerEvent(new PointerEvent("click", true, nativeEvent, this, this.intersection, camera));
    const { object } = this.intersection;
    const buttonsClickTime = object[buttonsClickTimeKey] ?? (object[buttonsClickTimeKey] = /* @__PURE__ */ new Map());
    const buttonClickTime = buttonsClickTime.get(nativeEvent.button);
    if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {
      buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);
      return;
    }
    emitPointerEvent(new PointerEvent("dblclick", true, nativeEvent, this, this.intersection, camera));
    buttonsClickTime.delete(nativeEvent.button);
  }
  cancel(nativeEvent) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.cancel.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointercancel", true, nativeEvent, this, this.intersection, this.getCamera()));
  }
  wheel(scene, nativeEvent, useMoveIntersection = false) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved && useMoveIntersection) {
      this.onFirstMove.push(this.wheel.bind(this, scene, nativeEvent, useMoveIntersection));
      return;
    }
    if (!useMoveIntersection) {
      this.wheelIntersection = this.computeIntersection("wheel", scene, nativeEvent);
    }
    const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;
    if (intersection == null) {
      return;
    }
    emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));
  }
  emitWheel(nativeEvent, useMoveIntersection = false) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved && useMoveIntersection) {
      this.onFirstMove.push(this.emitWheel.bind(this, nativeEvent, useMoveIntersection));
      return;
    }
    const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;
    if (intersection == null) {
      return;
    }
    emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));
  }
  exit(nativeEvent) {
    var _a;
    if (this.wasMoved) {
      if (this.pointerCapture != null) {
        (_a = this.parentReleasePointerCapture) == null ? void 0 : _a.call(this);
        this.pointerCapture = void 0;
      }
      this.intersection = void 0;
      this.commit(nativeEvent, false);
    }
    this.onFirstMove.length = 0;
    this.wasMoved = false;
  }
};
function computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {
  if (currentObject == null) {
    return;
  }
  const index = targeDiffRemovedAncestors.indexOf(currentObject);
  if (index != -1) {
    targeDiffRemovedAncestors.splice(index, 1);
  } else {
    targetDiffAddedAncestors.push(currentObject);
  }
  targetAllAncestors.push(currentObject);
  computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);
}
function getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThresholdMs) {
  if (objectButtonsDownTime == null) {
    return false;
  }
  const objectButtonPressTime = objectButtonsDownTime.get(button);
  if (objectButtonPressTime == null) {
    return false;
  }
  if (buttonUpTime - objectButtonPressTime > clickThresholdMs) {
    return false;
  }
  if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {
    return false;
  }
  return true;
}

// node_modules/@pmndrs/pointer-events/dist/utils.js
function updateAndCheckWorldTransformation(object) {
  if (object.transformReady === false) {
    return false;
  }
  if (object.parent == null) {
    object.matrixWorld.copy(object.matrix);
    return true;
  }
  if (!updateAndCheckWorldTransformation(object.parent)) {
    return false;
  }
  object.matrixWorld.multiplyMatrices(object.parent.matrixWorld, object.matrix);
  return true;
}
var triangleHelper1 = new Triangle();
var triangleHelper2 = new Triangle();
var aVec2Helper = new Vector2();
var bVec2Helper = new Vector2();
var cVec2Helper = new Vector2();
var pointHelper = new Vector3();
var inverseMatrix = new Matrix4();
var localPointHelper = new Vector3();
function getClosestUV(target, point, mesh) {
  localPointHelper.copy(point).applyMatrix4(inverseMatrix.copy(mesh.matrixWorld).invert());
  const uv = mesh.geometry.attributes.uv;
  if (uv == null || !(uv instanceof BufferAttribute)) {
    return false;
  }
  let clostestDistance;
  loopThroughTriangles(mesh, (i1, i2, i3) => {
    mesh.getVertexPosition(i1, triangleHelper1.a);
    mesh.getVertexPosition(i2, triangleHelper1.b);
    mesh.getVertexPosition(i3, triangleHelper1.c);
    const distance = triangleHelper1.closestPointToPoint(localPointHelper, pointHelper).distanceTo(localPointHelper);
    if (clostestDistance != null && distance >= clostestDistance) {
      return;
    }
    clostestDistance = distance;
    triangleHelper2.copy(triangleHelper1);
    aVec2Helper.fromBufferAttribute(uv, i1);
    bVec2Helper.fromBufferAttribute(uv, i2);
    cVec2Helper.fromBufferAttribute(uv, i3);
  });
  if (clostestDistance == null) {
    return false;
  }
  triangleHelper2.closestPointToPoint(localPointHelper, pointHelper);
  triangleHelper2.getInterpolation(pointHelper, aVec2Helper, bVec2Helper, cVec2Helper, target);
  return true;
}
function loopThroughTriangles(mesh, fn) {
  const drawRange = mesh.geometry.drawRange;
  if (mesh.geometry.index != null) {
    const index = mesh.geometry.index;
    const start2 = Math.max(0, drawRange.start);
    const end2 = Math.min(index.count, drawRange.start + drawRange.count);
    for (let i = start2; i < end2; i += 3) {
      fn(index.getX(i), index.getX(i + 1), index.getX(i + 2));
    }
    return;
  }
  const position = mesh.geometry.attributes.position;
  if (position == null) {
    return;
  }
  const start = Math.max(0, drawRange.start);
  const end = Math.min(position.count, drawRange.start + drawRange.count);
  for (let i = start; i < end; i += 3) {
    fn(i, i + 1, i + 2);
  }
}

// node_modules/@pmndrs/pointer-events/dist/intersections/lines.js
var invertedMatrixHelper = new Matrix4();
var lineHelper = new Line3();
var scaleHelper = new Vector3();
var planeHelper = new Plane();
var rayHelper = new Ray();
var point2Helper = new Vector2();
var defaultLinePoints = [new Vector3(0, 0, 0), new Vector3(0, 0, 1)];
var LinesIntersector = class {
  constructor(space, options) {
    __publicField(this, "space");
    __publicField(this, "options");
    __publicField(this, "raycasters", []);
    __publicField(this, "fromMatrixWorld", new Matrix4());
    __publicField(this, "ready");
    __publicField(this, "intersects", []);
    __publicField(this, "pointerEventsOrders", []);
    __publicField(this, "raycasterIndices", []);
    this.space = space;
    this.options = options;
  }
  isReady() {
    return this.ready ?? this.prepareTransformation();
  }
  prepareTransformation() {
    const spaceObject = this.space.current;
    if (spaceObject == null) {
      return this.ready = false;
    }
    this.ready = updateAndCheckWorldTransformation(spaceObject);
    if (!this.ready) {
      return false;
    }
    this.fromMatrixWorld.copy(spaceObject.matrixWorld);
    return true;
  }
  intersectPointerCapture({ intersection, object }) {
    const details = intersection.details;
    if (details.type != "lines") {
      throw new Error(`unable to process a pointer capture of type "${intersection.details.type}" with a lines intersector`);
    }
    if (!this.prepareTransformation()) {
      return intersection;
    }
    const linePoints = this.options.linePoints ?? defaultLinePoints;
    lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(this.fromMatrixWorld);
    const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());
    intersection.object.updateWorldMatrix(true, false);
    computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);
    const pointOnFace = rayHelper.intersectPlane(planeHelper, new Vector3()) ?? point;
    const pointerPosition = new Vector3();
    const pointerQuaternion = new Quaternion();
    this.fromMatrixWorld.decompose(pointerPosition, pointerQuaternion, scaleHelper);
    let uv = intersection.uv;
    if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {
      uv = point2Helper.clone();
    }
    return {
      ...intersection,
      object,
      uv,
      pointOnFace,
      point,
      pointerPosition,
      pointerQuaternion
    };
  }
  startIntersection() {
    if (!this.prepareTransformation()) {
      return;
    }
    const linePoints = this.options.linePoints ?? defaultLinePoints;
    const length = linePoints.length - 1;
    for (let i = 0; i < length; i++) {
      const start = linePoints[i];
      const end = linePoints[i + 1];
      const raycaster = this.raycasters[i] ?? (this.raycasters[i] = new Raycaster());
      raycaster.ray.origin.copy(start).applyMatrix4(this.fromMatrixWorld);
      raycaster.ray.direction.copy(end).applyMatrix4(this.fromMatrixWorld);
      raycaster.ray.direction.sub(raycaster.ray.origin);
      const lineLength = raycaster.ray.direction.length();
      raycaster.ray.direction.divideScalar(lineLength);
      raycaster.far = lineLength;
    }
    this.raycasters.length = length;
    return;
  }
  executeIntersection(object, objectPointerEventsOrder) {
    if (!this.isReady()) {
      return;
    }
    const startOuter = this.intersects.length;
    const length = this.raycasters.length;
    for (let i = 0; i < length; i++) {
      const raycaster = this.raycasters[i];
      const startInner = this.intersects.length;
      object.raycast(raycaster, this.intersects);
      pushTimes(this.raycasterIndices, i, this.intersects.length - startInner);
    }
    pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - startOuter);
  }
  finalizeIntersection(scene) {
    const pointerPosition = new Vector3().setFromMatrixPosition(this.fromMatrixWorld);
    const pointerQuaternion = new Quaternion().setFromRotationMatrix(this.fromMatrixWorld);
    const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);
    const intersection = index == null ? void 0 : this.intersects[index];
    const raycasterIndex = index == null ? void 0 : this.raycasterIndices[index];
    this.intersects.length = 0;
    this.raycasterIndices.length = 0;
    this.pointerEventsOrders.length = 0;
    if (intersection == null || raycasterIndex == null) {
      const lastRaycasterIndex = this.raycasters.length - 1;
      const prevDistance = this.raycasters.reduce((prev, caster, i) => i === lastRaycasterIndex ? prev : prev + caster.far, 0);
      const lastRaycaster = this.raycasters[lastRaycasterIndex];
      return voidObjectIntersectionFromRay(scene, lastRaycaster.ray, (point, distanceOnLine) => ({
        line: new Line3(lastRaycaster.ray.origin.clone(), point),
        lineIndex: this.raycasters.length - 1,
        distanceOnLine,
        type: "lines"
      }), pointerPosition, pointerQuaternion, prevDistance);
    }
    let distance = intersection.distance;
    for (let i = 0; i < raycasterIndex; i++) {
      distance += this.raycasters[i].far;
    }
    intersection.object.updateWorldMatrix(true, false);
    const raycaster = this.raycasters[raycasterIndex];
    return Object.assign(intersection, {
      details: {
        lineIndex: raycasterIndex,
        distanceOnLine: intersection.distance,
        type: "lines",
        line: new Line3(raycaster.ray.origin.clone(), raycaster.ray.direction.clone().multiplyScalar(raycaster.far).add(raycaster.ray.origin))
      },
      distance,
      pointerPosition,
      pointerQuaternion,
      pointOnFace: intersection.point,
      localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert())
    });
  }
};

// node_modules/@pmndrs/pointer-events/dist/intersections/ray.js
var invertedMatrixHelper2 = new Matrix4();
var scaleHelper2 = new Vector3();
var NegZAxis = new Vector3(0, 0, -1);
var planeHelper2 = new Plane();
var point2Helper2 = new Vector2();
var RayIntersector = class {
  constructor(space, options) {
    __publicField(this, "space");
    __publicField(this, "options");
    __publicField(this, "raycaster", new Raycaster());
    __publicField(this, "raycasterQuaternion", new Quaternion());
    __publicField(this, "worldScale", 0);
    __publicField(this, "ready");
    __publicField(this, "intersects", []);
    __publicField(this, "pointerEventsOrders", []);
    this.space = space;
    this.options = options;
  }
  isReady() {
    return this.ready ?? this.prepareTransformation();
  }
  prepareTransformation() {
    var _a;
    const spaceObject = this.space.current;
    if (spaceObject == null) {
      return this.ready = false;
    }
    this.ready = updateAndCheckWorldTransformation(spaceObject);
    if (!this.ready) {
      return false;
    }
    spaceObject.matrixWorld.decompose(this.raycaster.ray.origin, this.raycasterQuaternion, scaleHelper2);
    this.worldScale = scaleHelper2.x;
    this.raycaster.ray.direction.copy(((_a = this.options) == null ? void 0 : _a.direction) ?? NegZAxis).applyQuaternion(this.raycasterQuaternion);
    return true;
  }
  intersectPointerCapture({ intersection, object }) {
    if (intersection.details.type != "ray") {
      throw new Error(`unable to process a pointer capture of type "${intersection.details.type}" with a ray intersector`);
    }
    if (!this.prepareTransformation()) {
      return intersection;
    }
    intersection.object.updateWorldMatrix(true, false);
    computeIntersectionWorldPlane(planeHelper2, intersection, intersection.object.matrixWorld);
    const { ray } = this.raycaster;
    const pointOnFace = ray.intersectPlane(planeHelper2, new Vector3()) ?? intersection.point;
    const point = ray.direction.clone().multiplyScalar(intersection.pointerPosition.distanceTo(intersection.point)).add(ray.origin);
    let uv = intersection.uv;
    if (intersection.object instanceof Mesh && getClosestUV(point2Helper2, point, intersection.object)) {
      uv = point2Helper2.clone();
    }
    return {
      ...intersection,
      uv,
      object,
      pointOnFace,
      point,
      pointerPosition: ray.origin.clone(),
      pointerQuaternion: this.raycasterQuaternion.clone()
    };
  }
  startIntersection() {
    this.prepareTransformation();
  }
  executeIntersection(object, objectPointerEventsOrder) {
    if (!this.isReady()) {
      return;
    }
    const start = this.intersects.length;
    object.raycast(this.raycaster, this.intersects);
    pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);
  }
  finalizeIntersection(scene) {
    const pointerPosition = this.raycaster.ray.origin.clone();
    const pointerQuaternion = this.raycasterQuaternion.clone();
    let filter;
    if (this.options.minDistance != null) {
      const localMinDistance = this.options.minDistance / this.worldScale;
      filter = (intersection2) => intersection2.distance >= localMinDistance;
    }
    const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options, filter);
    const intersection = index == null ? void 0 : this.intersects[index];
    this.intersects.length = 0;
    this.pointerEventsOrders.length = 0;
    if (intersection == null) {
      return voidObjectIntersectionFromRay(scene, this.raycaster.ray, () => ({ type: "ray" }), pointerPosition, pointerQuaternion);
    }
    intersection.object.updateWorldMatrix(true, false);
    return Object.assign(intersection, {
      details: {
        type: "ray"
      },
      pointerPosition,
      pointerQuaternion,
      pointOnFace: intersection.point,
      localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper2.copy(intersection.object.matrixWorld).invert())
    });
  }
};
var directionHelper = new Vector3();
var ScreenRayIntersector = class {
  constructor(prepareTransformation, options) {
    __publicField(this, "prepareTransformation");
    __publicField(this, "options");
    __publicField(this, "raycaster", new Raycaster());
    __publicField(this, "cameraQuaternion", new Quaternion());
    __publicField(this, "fromPosition", new Vector3());
    __publicField(this, "fromQuaternion", new Quaternion());
    __publicField(this, "coords", new Vector2());
    __publicField(this, "viewPlane", new Plane());
    __publicField(this, "intersects", []);
    __publicField(this, "pointerEventsOrders", []);
    this.prepareTransformation = prepareTransformation;
    this.options = options;
  }
  isReady() {
    return true;
  }
  intersectPointerCapture({ intersection, object }, nativeEvent) {
    const details = intersection.details;
    if (details.type != "screen-ray") {
      throw new Error(`unable to process a pointer capture of type "${intersection.details.type}" with a camera ray intersector`);
    }
    if (!this.startIntersection(nativeEvent)) {
      return intersection;
    }
    this.viewPlane.constant -= details.distanceViewPlane;
    const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());
    if (point == null) {
      return intersection;
    }
    intersection.object.updateWorldMatrix(true, false);
    computeIntersectionWorldPlane(this.viewPlane, intersection, intersection.object.matrixWorld);
    let uv = intersection.uv;
    if (intersection.object instanceof Mesh && getClosestUV(point2Helper2, point, intersection.object)) {
      uv = point2Helper2.clone();
    }
    return {
      ...intersection,
      details: {
        ...details,
        direction: this.raycaster.ray.direction.clone(),
        screenPoint: this.coords.clone()
      },
      uv,
      object,
      point,
      pointOnFace: point,
      pointerPosition: this.raycaster.ray.origin.clone(),
      pointerQuaternion: this.cameraQuaternion.clone()
    };
  }
  startIntersection(nativeEvent) {
    const from = this.prepareTransformation(nativeEvent, this.coords);
    if (from == null) {
      return false;
    }
    from.updateWorldMatrix(true, false);
    from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper2);
    this.raycaster.setFromCamera(this.coords, from);
    this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);
    return true;
  }
  executeIntersection(object, objectPointerEventsOrder) {
    const start = this.intersects.length;
    object.raycast(this.raycaster, this.intersects);
    pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);
  }
  finalizeIntersection(scene) {
    const pointerPosition = this.fromPosition.clone();
    const pointerQuaternion = this.cameraQuaternion.clone();
    const pointerDirection = this.raycaster.ray.direction.clone();
    const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);
    const intersection = index == null ? void 0 : this.intersects[index];
    this.intersects.length = 0;
    this.pointerEventsOrders.length = 0;
    if (intersection == null) {
      return voidObjectIntersectionFromRay(scene, this.raycaster.ray, (_point, distance) => ({
        type: "screen-ray",
        distanceViewPlane: distance,
        screenPoint: this.coords.clone(),
        direction: pointerDirection
      }), pointerPosition, pointerQuaternion);
    }
    intersection.object.updateWorldMatrix(true, false);
    invertedMatrixHelper2.copy(intersection.object.matrixWorld).invert();
    return Object.assign(intersection, {
      details: {
        type: "screen-ray",
        distanceViewPlane: this.viewPlane.distanceToPoint(intersection.point),
        screenPoint: this.coords.clone(),
        direction: pointerDirection
      },
      pointOnFace: intersection.point,
      pointerPosition,
      pointerQuaternion,
      localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper2)
    });
  }
};

// node_modules/@pmndrs/pointer-events/dist/forward.js
function htmlEventToCoords(element, e, target) {
  if (!(e instanceof globalThis.MouseEvent)) {
    return target.set(0, 0);
  }
  const { width, height, top, left } = element.getBoundingClientRect();
  const x = e.clientX - left;
  const y = e.clientY - top;
  return target.set(x / width * 2 - 1, -(y / height) * 2 + 1);
}
function forwardHtmlEvents(fromElement, getCamera, scene, options) {
  return forwardEvents(
    fromElement,
    //backwards compatibility
    typeof getCamera === "function" ? getCamera : () => getCamera,
    scene,
    htmlEventToCoords.bind(null, fromElement),
    fromElement.setPointerCapture.bind(fromElement),
    (pointerId) => {
      if (fromElement.hasPointerCapture(pointerId)) {
        fromElement.releasePointerCapture(pointerId);
      }
    },
    {
      pointerTypePrefix: "screen-",
      ...options
    }
  );
}
function portalEventToCoords(e, target) {
  if (!(e instanceof PointerEvent)) {
    return target.set(0, 0);
  }
  if (e.uv == null) {
    return target.set(0, 0);
  }
  return target.copy(e.uv).multiplyScalar(2).addScalar(-1);
}
function forwardObjectEvents(fromPortal, getCamera, scene, options) {
  return forwardEvents(fromPortal, getCamera, scene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);
}
function forwardEvents(from, getCamera, scene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {
  const forwardPointerCapture = (options == null ? void 0 : options.forwardPointerCapture) ?? true;
  const pointerMap = /* @__PURE__ */ new Map();
  const pointerTypePrefix = options.pointerTypePrefix ?? "forward-";
  const getInnerPointer = (event, eventType) => {
    let innerPointer = pointerMap.get(event.pointerId);
    if (innerPointer != null) {
      return innerPointer;
    }
    innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${event.pointerType}`, event.pointerState, new ScreenRayIntersector((nativeEvent, coords) => {
      toCoords(nativeEvent, coords);
      return getCamera();
    }, options), getCamera, void 0, forwardPointerCapture ? setPointerCapture.bind(null, event.pointerId) : void 0, forwardPointerCapture ? releasePointerCapture.bind(null, event.pointerId) : void 0, options);
    if (eventType != "move" && eventType != "wheel") {
      innerPointer.setIntersection(innerPointer.computeIntersection("pointer", scene, event));
      innerPointer.commit(event, false);
    }
    pointerMap.set(event.pointerId, innerPointer);
    return innerPointer;
  };
  const latestWheelEventMap = /* @__PURE__ */ new Map();
  const latestMoveEventMap = /* @__PURE__ */ new Map();
  const movedPointerList = [];
  const eventList = [];
  const emitEvent = (type, event, pointer) => {
    switch (type) {
      case "move":
        pointer.move(scene, event);
        return;
      case "over":
        pointer.move(scene, event);
        return;
      case "wheel":
        pointer.wheel(scene, event);
        return;
      case "cancel":
        pointer.cancel(event);
        return;
      case "down":
        if (!hasButton(event)) {
          return;
        }
        pointer.down(event);
        return;
      case "up":
        if (!hasButton(event)) {
          return;
        }
        pointer.up(event);
        return;
      case "exit":
        latestMoveEventMap.delete(pointer);
        latestWheelEventMap.delete(pointer);
        pointer.exit(event);
        return;
    }
  };
  const onEvent = (type, event) => {
    const pointer = getInnerPointer(event, type);
    if (type === "move") {
      latestMoveEventMap.set(pointer, event);
    }
    if (type === "wheel") {
      latestWheelEventMap.set(pointer, event);
    }
    if (options.batchEvents ?? true) {
      eventList.push({ type, event });
    } else {
      emitEvent(type, event, pointer);
    }
  };
  const pointerMoveListener = onEvent.bind(null, "move");
  const pointerOverListener = onEvent.bind(null, "over");
  const pointerCancelListener = onEvent.bind(null, "cancel");
  const pointerDownListener = onEvent.bind(null, "down");
  const pointerUpListener = onEvent.bind(null, "up");
  const wheelListener = onEvent.bind(null, "wheel");
  const pointerLeaveListener = onEvent.bind(null, "exit");
  from.addEventListener("pointermove", pointerMoveListener);
  from.addEventListener("pointerover", pointerOverListener);
  from.addEventListener("pointercancel", pointerCancelListener);
  from.addEventListener("pointerdown", pointerDownListener);
  from.addEventListener("pointerup", pointerUpListener);
  from.addEventListener("wheel", wheelListener);
  from.addEventListener("pointerleave", pointerLeaveListener);
  return {
    destroy() {
      from.removeEventListener("pointermove", pointerMoveListener);
      from.removeEventListener("pointerover", pointerOverListener);
      from.removeEventListener("pointercancel", pointerCancelListener);
      from.removeEventListener("pointerdown", pointerDownListener);
      from.removeEventListener("pointerup", pointerUpListener);
      from.removeEventListener("wheel", wheelListener);
      from.removeEventListener("pointerleave", pointerLeaveListener);
      latestMoveEventMap.clear();
      latestWheelEventMap.clear();
    },
    update() {
      const length = eventList.length;
      for (let i = 0; i < length; i++) {
        const { type, event } = eventList[i];
        const pointer = getInnerPointer(event, type);
        if (type === "move") {
          movedPointerList.push(pointer);
          if (latestMoveEventMap.get(pointer) != event) {
            pointer.emitMove(event);
            continue;
          }
        }
        if (type === "wheel" && latestWheelEventMap.get(pointer) != event) {
          pointer.emitWheel(event);
          continue;
        }
        emitEvent(type, event, pointer);
      }
      eventList.length = 0;
      if (options.intersectEveryFrame ?? false) {
        for (const [pointer, event] of latestMoveEventMap.entries()) {
          if (movedPointerList.includes(pointer)) {
            continue;
          }
          pointer.move(scene, event);
        }
      }
      movedPointerList.length = 0;
    }
  };
}
function hasButton(val) {
  return val.button != null;
}

// node_modules/@pmndrs/pointer-events/dist/combine.js
var CombinedPointer = class _CombinedPointer {
  constructor(enableMultiplePointers) {
    __publicField(this, "enableMultiplePointers");
    __publicField(this, "pointers", []);
    __publicField(this, "isDefaults", []);
    __publicField(this, "enabled", true);
    __publicField(this, "activePointer");
    __publicField(this, "nonCapturedPointers", []);
    this.enableMultiplePointers = enableMultiplePointers;
  }
  register(pointer, isDefault = false) {
    this.pointers.push(pointer);
    this.isDefaults.push(isDefault);
    return this.unregister.bind(this, pointer);
  }
  unregister(pointer) {
    const index = this.pointers.indexOf(pointer);
    if (index === -1) {
      return;
    }
    this.isDefaults.splice(index, 1);
    this.pointers.splice(index, 1);
  }
  /**
   * @returns true if any pointer is captured
   */
  startIntersection(nonCapturedPointers, nativeEvent) {
    const length = this.pointers.length;
    let anyPointerIsCaptured = false;
    for (let i = 0; i < length; i++) {
      const pointer = this.pointers[i];
      if (pointer instanceof _CombinedPointer) {
        pointer.startIntersection(nonCapturedPointers, nativeEvent);
        continue;
      }
      const pointerCapture = pointer.getPointerCapture();
      if (pointerCapture != null) {
        anyPointerIsCaptured = true;
        pointer.setIntersection(pointer.intersector.intersectPointerCapture(pointerCapture, nativeEvent));
        continue;
      }
      nonCapturedPointers.push(pointer);
      pointer.intersector.startIntersection(nativeEvent);
    }
    return anyPointerIsCaptured;
  }
  /**
   * only for internal use
   */
  getIntersection() {
    var _a;
    return (_a = this.activePointer) == null ? void 0 : _a.getIntersection();
  }
  /**
   * only for internal use
   */
  getPointerCapture() {
    var _a;
    return (_a = this.activePointer) == null ? void 0 : _a.getPointerCapture();
  }
  computeActivePointer() {
    let smallestDistance;
    this.activePointer = void 0;
    const length = this.pointers.length;
    for (let i = 0; i < length; i++) {
      const pointer = this.pointers[i];
      if (pointer instanceof _CombinedPointer) {
        pointer.computeActivePointer();
      }
      const intersection = pointer.getIntersection();
      const distance = pointer.getPointerCapture() != null ? -Infinity : (intersection == null ? void 0 : intersection.object.isVoidObject) ? Infinity : (intersection == null ? void 0 : intersection.distance) ?? Infinity;
      const isDefault = this.isDefaults[i];
      if (smallestDistance == null || isDefault && distance === smallestDistance || distance < smallestDistance) {
        this.activePointer = pointer;
        smallestDistance = distance;
      }
    }
  }
  /**
   * only for internal use
   */
  commit(nativeEvent, emitMove, computeActivePointer = true) {
    if (this.enableMultiplePointers) {
      const length2 = this.pointers.length;
      for (let i = 0; i < length2; i++) {
        this.pointers[i].commit(nativeEvent, emitMove);
      }
      return;
    }
    if (computeActivePointer) {
      this.computeActivePointer();
    }
    const length = this.pointers.length;
    for (let i = 0; i < length; i++) {
      const pointer = this.pointers[i];
      pointer.setEnabled(pointer === this.activePointer, nativeEvent, false);
      pointer.commit(nativeEvent, emitMove, false);
    }
  }
  move(scene, nativeEvent) {
    if (!this.enabled) {
      return;
    }
    this.nonCapturedPointers.length = 0;
    const anyPointerIsCaptured = this.startIntersection(this.nonCapturedPointers, nativeEvent);
    if (!anyPointerIsCaptured || this.enableMultiplePointers) {
      intersectPointerEventTargets("pointer", scene, this.nonCapturedPointers);
      const nonCapturedPointerLength = this.nonCapturedPointers.length;
      for (let i = 0; i < nonCapturedPointerLength; i++) {
        const pointer = this.nonCapturedPointers[i];
        pointer.setIntersection(pointer.intersector.finalizeIntersection(scene));
      }
    }
    this.commit(nativeEvent, true);
  }
  setEnabled(enabled, nativeEvent) {
    this.enabled = enabled;
    const length = this.pointers.length;
    for (let i = 0; i < length; i++) {
      const pointer = this.pointers[i];
      pointer.setEnabled(enabled && (this.enableMultiplePointers || pointer == this.activePointer), nativeEvent);
    }
  }
};

// node_modules/@pmndrs/pointer-events/dist/intersections/sphere.js
var scaleHelper3 = new Vector3();
var point2Helper3 = new Vector2();
var SphereIntersector = class {
  constructor(space, getSphereRadius, options) {
    __publicField(this, "space");
    __publicField(this, "getSphereRadius");
    __publicField(this, "options");
    __publicField(this, "fromPosition", new Vector3());
    __publicField(this, "fromQuaternion", new Quaternion());
    __publicField(this, "collisionSphere", new Sphere());
    __publicField(this, "ready");
    __publicField(this, "intersects", []);
    this.space = space;
    this.getSphereRadius = getSphereRadius;
    this.options = options;
  }
  isReady() {
    return this.ready ?? this.prepareTransformation();
  }
  prepareTransformation() {
    const spaceObject = this.space.current;
    if (spaceObject == null) {
      return this.ready = false;
    }
    this.ready = updateAndCheckWorldTransformation(spaceObject);
    if (!this.ready) {
      return false;
    }
    spaceObject.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper3);
    return true;
  }
  intersectPointerCapture({ intersection, object }) {
    if (intersection.details.type != "sphere") {
      throw new Error(`unable to process a pointer capture of type "${intersection.details.type}" with a sphere intersector`);
    }
    if (!this.prepareTransformation()) {
      return intersection;
    }
    oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);
    inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(this.fromQuaternion);
    const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(this.fromPosition);
    intersection.object.updateWorldMatrix(true, false);
    computeIntersectionWorldPlane(planeHelper3, intersection, intersection.object.matrixWorld);
    const pointOnFace = planeHelper3.projectPoint(this.fromPosition, new Vector3());
    let uv = intersection.uv;
    if (intersection.object instanceof Mesh && getClosestUV(point2Helper3, point, intersection.object)) {
      uv = point2Helper3.clone();
    }
    return {
      details: {
        type: "sphere"
      },
      uv,
      distance: point.distanceTo(pointOnFace),
      pointerPosition: this.fromPosition.clone(),
      pointerQuaternion: this.fromQuaternion.clone(),
      object,
      point,
      pointOnFace,
      face: intersection.face,
      localPoint: intersection.localPoint
    };
  }
  startIntersection() {
    if (!this.prepareTransformation()) {
      return;
    }
    this.collisionSphere.center.copy(this.fromPosition);
    this.collisionSphere.radius = this.getSphereRadius();
  }
  executeIntersection(object) {
    if (!this.isReady()) {
      return;
    }
    intersectSphereWithObject(this.collisionSphere, object, this.intersects);
  }
  finalizeIntersection(scene) {
    const pointerPosition = this.fromPosition.clone();
    const pointerQuaternion = this.fromQuaternion.clone();
    const index = getDominantIntersectionIndex(this.intersects, void 0, this.options);
    const intersection = index == null ? void 0 : this.intersects[index];
    this.intersects.length = 0;
    if (intersection == null) {
      return {
        details: {
          type: "sphere"
        },
        distance: 0,
        point: pointerPosition,
        object: getVoidObject(scene),
        pointerPosition,
        pointerQuaternion,
        pointOnFace: pointerPosition,
        localPoint: pointerPosition
      };
    }
    intersection.object.updateWorldMatrix(true, false);
    return Object.assign(intersection, {
      details: {
        type: "sphere"
      },
      pointOnFace: intersection.point,
      pointerPosition: this.fromPosition.clone(),
      pointerQuaternion: this.fromQuaternion.clone(),
      localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper3.copy(intersection.object.matrixWorld).invert())
    });
  }
};
var matrixHelper = new Matrix4();
function intersectSphereWithObject(pointerSphere, object, target) {
  object.updateWorldMatrix(true, false);
  if (object.spherecast != null) {
    object.spherecast(pointerSphere, target);
    return;
  }
  if (object instanceof InstancedMesh) {
    if (object.geometry.boundingSphere == null) {
      object.geometry.computeBoundingSphere();
    }
    if (object.geometry.boundingBox == null) {
      object.geometry.computeBoundingBox();
    }
    for (let i = 0; i < object.count; i++) {
      object.getMatrixAt(i, matrixHelper);
      matrixHelper.premultiply(object.matrixWorld);
      if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper)) {
        continue;
      }
      const intersection2 = intersectSphereMesh(pointerSphere, object, matrixHelper, i);
      if (intersection2 == null) {
        continue;
      }
      target.push(intersection2);
    }
  }
  if (!(object instanceof Mesh)) {
    return;
  }
  if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {
    return;
  }
  invertedMatrixHelper3.copy(object.matrixWorld).invert();
  const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);
  if (intersection == null) {
    return;
  }
  target.push(intersection);
}
var oldInputDevicePointOffset = new Vector3();
var inputDeviceQuaternionOffset = new Quaternion();
var planeHelper3 = new Plane();
var helperSphere = new Sphere();
function isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {
  if (geometry.boundingSphere == null) {
    geometry.computeBoundingSphere();
  }
  helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);
  return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;
}
var vectorHelper = new Vector3();
var boxSizeHelper = new Vector3();
var boxCenterHelper = new Vector3();
var vec0_0001 = new Vector3(1e-4, 1e-4, 1e-4);
var invertedMatrixHelper3 = new Matrix4();
function intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {
  invertedMatrixHelper3.copy(meshMatrixWorld).invert();
  helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper3);
  const { geometry } = mesh;
  if (geometry.boundingBox == null) {
    geometry.computeBoundingBox();
  }
  geometry.boundingBox.getSize(boxSizeHelper);
  geometry.boundingBox.getCenter(boxCenterHelper);
  geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper);
  vectorHelper.applyMatrix4(meshMatrixWorld);
  const distanceToSphereCenterSquared = vectorHelper.distanceToSquared(pointerSphere.center);
  if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {
    return void 0;
  }
  boxSizeHelper.max(vec0_0001);
  const normal = helperSphere.center.clone().sub(boxCenterHelper);
  normal.divide(boxSizeHelper);
  maximizeAxisVector(normal);
  const point = vectorHelper.clone();
  let uv;
  if (getClosestUV(point2Helper3, point, mesh)) {
    uv = point2Helper3.clone();
  }
  return {
    distance: Math.sqrt(distanceToSphereCenterSquared),
    face: {
      a: 0,
      b: 0,
      c: 0,
      materialIndex: 0,
      normal
    },
    uv,
    normal,
    point,
    instanceId,
    object: mesh
  };
}
function maximizeAxisVector(vec) {
  const absX = Math.abs(vec.x);
  const absY = Math.abs(vec.y);
  const absZ = Math.abs(vec.z);
  if (absX >= absY && absX >= absZ) {
    vec.set(vec.x < 0 ? -1 : 1, 0, 0);
    return;
  }
  if (absY >= absX && absY >= absZ) {
    vec.set(0, vec.y < 0 ? -1 : 1, 0);
    return;
  }
  vec.set(0, 0, vec.z < 0 ? -1 : 1);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/ray.js
function createRayPointer(getCamera, space, pointerState, options = {}, pointerType = "ray") {
  return new Pointer(generateUniquePointerId(), pointerType, pointerState, new RayIntersector(space, options), getCamera, void 0, void 0, void 0, options);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/lines.js
function createLinesPointer(getCamera, space, pointerState, options = {}, pointerType = "lines") {
  return new Pointer(generateUniquePointerId(), pointerType, pointerState, new LinesIntersector(space, options), getCamera, void 0, void 0, void 0, options);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/touch.js
function createTouchPointer(getCamera, space, pointerState, options = {}, pointerType = "touch") {
  return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.hoverRadius ?? 0.1, options), getCamera, createUpdateTouchPointer(options), void 0, void 0, options);
}
function createUpdateTouchPointer(options) {
  let wasPointerDown = false;
  return (pointer) => {
    if (!pointer.getEnabled()) {
      return;
    }
    const intersection = pointer.getIntersection();
    const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? 0.03);
    if (isPointerDown === wasPointerDown) {
      return;
    }
    const nativeEvent = { timeStamp: performance.now(), button: options.button ?? 0 };
    if (isPointerDown) {
      pointer.down(nativeEvent);
    } else {
      pointer.up(nativeEvent);
    }
    wasPointerDown = isPointerDown;
  };
}
function computeIsPointerDown(intersection, downRadius) {
  if (intersection == null) {
    return false;
  }
  return intersection.distance <= downRadius;
}

// node_modules/@pmndrs/pointer-events/dist/pointer/index.js
var pointerIdCounter = 23412;
function generateUniquePointerId() {
  return pointerIdCounter++;
}

// node_modules/@pmndrs/pointer-events/dist/pointer/grab.js
function createGrabPointer(getCamera, space, pointerState, options = {}, pointerType = "grab") {
  return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.radius ?? 0.07, options), getCamera, void 0, void 0, void 0, options);
}

// node_modules/three/src/math/MathUtils.js
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

export {
  clamp,
  PointerEvent,
  Pointer,
  createGrabPointer,
  createRayPointer,
  createLinesPointer,
  createTouchPointer,
  forwardHtmlEvents,
  forwardObjectEvents,
  CombinedPointer
};
//# sourceMappingURL=chunk-TFUTYRUX.js.map

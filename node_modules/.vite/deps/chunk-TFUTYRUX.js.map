{
  "version": 3,
  "sources": ["../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/html-event.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/event.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/intersections/intersector.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/intersections/utils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/utils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/intersections/lines.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/intersections/ray.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/forward.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/combine.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/intersections/sphere.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer/ray.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer/lines.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer/touch.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer/index.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/pointer-events/dist/pointer/grab.js", "../../../hidden-heritage-mvp/frontend/node_modules/three/src/math/MathUtils.js"],
  "sourcesContent": ["export class HtmlEvent {\n    nativeEvent;\n    NONE = 0;\n    CAPTURING_PHASE = 1;\n    AT_TARGET = 2;\n    BUBBLING_PHASE = 3;\n    relatedTarget = null;\n    get altKey() {\n        return this.getFromNative('altKey', false);\n    }\n    get button() {\n        return this.getFromNative('button', 0);\n    }\n    get buttons() {\n        return this.getFromNative('buttons', 0);\n    }\n    get clientX() {\n        return this.getFromNative('clientX', 0);\n    }\n    get clientY() {\n        return this.getFromNative('clientY', 0);\n    }\n    get ctrlKey() {\n        return this.getFromNative('ctrlKey', false);\n    }\n    get layerX() {\n        return this.getFromNative('layerX', 0);\n    }\n    get layerY() {\n        return this.getFromNative('layerY', 0);\n    }\n    get metaKey() {\n        return this.getFromNative('metaKey', false);\n    }\n    get movementX() {\n        return this.getFromNative('movementX', 0);\n    }\n    get movementY() {\n        return this.getFromNative('movementY', 0);\n    }\n    get offsetX() {\n        return this.getFromNative('offsetX', 0);\n    }\n    get offsetY() {\n        return this.getFromNative('offsetY', 0);\n    }\n    get pageX() {\n        return this.getFromNative('pageX', 0);\n    }\n    get pageY() {\n        return this.getFromNative('pageY', 0);\n    }\n    get screenX() {\n        return this.getFromNative('screenX', 0);\n    }\n    get screenY() {\n        return this.getFromNative('screenY', 0);\n    }\n    get shiftKey() {\n        return this.getFromNative('shiftKey', false);\n    }\n    get x() {\n        return this.getFromNative('x', 0);\n    }\n    get y() {\n        return this.getFromNative('y', 0);\n    }\n    get detail() {\n        return this.getFromNative('detail', 0);\n    }\n    get view() {\n        return this.getFromNative('view', null);\n    }\n    get which() {\n        return this.getFromNative('which', 0);\n    }\n    get cancelBubble() {\n        return this.getFromNative('cancelBubble', false);\n    }\n    get composed() {\n        return this.getFromNative('composed', false);\n    }\n    get eventPhase() {\n        return this.getFromNative('eventPhase', 0);\n    }\n    get isTrusted() {\n        return this.getFromNative('isTrusted', false);\n    }\n    get returnValue() {\n        return this.getFromNative('returnValue', false);\n    }\n    get timeStamp() {\n        return this.getFromNative('timeStamp', 0);\n    }\n    get cancelable() {\n        return this.getFromNative('cancelable', false);\n    }\n    get defaultPrevented() {\n        return this.getFromNative('defaultPrevented', false);\n    }\n    constructor(nativeEvent) {\n        this.nativeEvent = nativeEvent;\n    }\n    getFromNative(key, defaultValue) {\n        if (key in this.nativeEvent) {\n            return this.nativeEvent[key];\n        }\n        return defaultValue;\n    }\n}\n", "import { Ray, Vector2, Vector3 } from 'three';\nimport { HtmlEvent } from './html-event.js';\nconst helperVector = new Vector3();\nexport class PointerEvent extends HtmlEvent {\n    type;\n    bubbles;\n    internalPointer;\n    intersection;\n    camera;\n    currentObject;\n    object;\n    propagationState;\n    //--- pointer events data\n    get pointerId() {\n        return this.internalPointer.id;\n    }\n    get pointerType() {\n        return this.internalPointer.type;\n    }\n    get pointerState() {\n        return this.internalPointer.state;\n    }\n    //--- intersection data\n    get distance() {\n        return this.intersection.distance;\n    }\n    get distanceToRay() {\n        return this.intersection.distanceToRay;\n    }\n    get point() {\n        return this.intersection.point;\n    }\n    get index() {\n        return this.intersection.index;\n    }\n    get face() {\n        return this.intersection.face;\n    }\n    get faceIndex() {\n        return this.intersection.faceIndex;\n    }\n    get uv() {\n        return this.intersection.uv;\n    }\n    get uv1() {\n        return this.intersection.uv1;\n    }\n    get normal() {\n        return this.intersection.normal;\n    }\n    get instanceId() {\n        return this.intersection.instanceId;\n    }\n    get pointOnLine() {\n        return this.intersection.pointOnLine;\n    }\n    get batchId() {\n        return this.intersection.batchId;\n    }\n    get pointerPosition() {\n        return this.intersection.pointerPosition;\n    }\n    get pointerQuaternion() {\n        return this.intersection.pointerQuaternion;\n    }\n    get pointOnFace() {\n        return this.intersection.pointOnFace;\n    }\n    get localPoint() {\n        return this.intersection.localPoint;\n    }\n    get details() {\n        return this.intersection.details;\n    }\n    /** same as object */\n    get target() {\n        return this.object;\n    }\n    /** same as currentObject */\n    get currentTarget() {\n        return this.currentObject;\n    }\n    /** same as currentObject */\n    get eventObject() {\n        return this.currentObject;\n    }\n    /** same as object */\n    get srcElement() {\n        return this.currentObject;\n    }\n    _pointer;\n    get pointer() {\n        if (this._pointer == null) {\n            helperVector.copy(this.intersection.point).project(this.camera);\n            this._pointer = new Vector2(helperVector.x, helperVector.y);\n        }\n        return this._pointer;\n    }\n    _ray;\n    get ray() {\n        if (this._ray != null) {\n            return this._ray;\n        }\n        switch (this.intersection.details.type) {\n            case 'screen-ray':\n            case 'ray':\n            case 'sphere':\n                return (this._ray = new Ray(this.intersection.pointerPosition, new Vector3(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion)));\n            case 'lines':\n                return (this._ray = new Ray(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize()));\n        }\n    }\n    _intersections = [];\n    get intersections() {\n        if (this._intersections == null) {\n            this._intersections = [{ ...this.intersection, eventObject: this.currentObject }];\n        }\n        return this._intersections;\n    }\n    _unprojectedPoint;\n    get unprojectedPoint() {\n        if (this._unprojectedPoint == null) {\n            const p = this.pointer;\n            this._unprojectedPoint = new Vector3(p.x, p.y, 0).unproject(this.camera);\n        }\n        return this._unprojectedPoint;\n    }\n    get stopped() {\n        return this.propagationState.stoppedImmediate || this.propagationState.stopped;\n    }\n    get stoppedImmediate() {\n        return this.propagationState.stoppedImmediate;\n    }\n    get delta() {\n        throw new Error(`not supported`);\n    }\n    constructor(type, bubbles, nativeEvent, internalPointer, intersection, camera, currentObject = intersection.object, object = currentObject, propagationState = {\n        stopped: !bubbles,\n        stoppedImmediate: false,\n    }) {\n        super(nativeEvent);\n        this.type = type;\n        this.bubbles = bubbles;\n        this.internalPointer = internalPointer;\n        this.intersection = intersection;\n        this.camera = camera;\n        this.currentObject = currentObject;\n        this.object = object;\n        this.propagationState = propagationState;\n    }\n    stopPropagation() {\n        this.propagationState.stopped = true;\n    }\n    stopImmediatePropagation() {\n        this.propagationState.stoppedImmediate = true;\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        return new PointerEvent(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target, this.propagationState);\n    }\n}\nexport class WheelEvent extends PointerEvent {\n    get deltaX() {\n        return this.nativeEvent.deltaX;\n    }\n    get deltaY() {\n        return this.nativeEvent.deltaY;\n    }\n    get deltaZ() {\n        return this.nativeEvent.deltaZ;\n    }\n    constructor(nativeEvent, pointer, intersection, camera, currentObject, object) {\n        super('wheel', true, nativeEvent, pointer, intersection, camera, currentObject, object);\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        return new WheelEvent(this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target);\n    }\n}\nexport function emitPointerEvent(event) {\n    emitPointerEventRec(event, event.currentObject);\n}\nfunction emitPointerEventRec(baseEvent, currentObject) {\n    if (currentObject == null) {\n        return;\n    }\n    const listeners = getObjectListeners(currentObject, baseEvent.type);\n    if (listeners != null && listeners.length > 0) {\n        const event = baseEvent.retarget(currentObject);\n        const length = listeners.length;\n        for (let i = 0; i < length && !event.stoppedImmediate; i++) {\n            listeners[i](event);\n        }\n    }\n    if (baseEvent.stopped) {\n        return;\n    }\n    emitPointerEventRec(baseEvent, currentObject.parent);\n}\nconst r3fEventToHandlerMap = {\n    click: 'onClick',\n    contextmenu: 'onContextMenu',\n    dblclick: 'onDoubleClick',\n    pointercancel: 'onPointerCancel',\n    pointerdown: 'onPointerDown',\n    pointerenter: 'onPointerEnter',\n    pointerleave: 'onPointerLeave',\n    pointermove: 'onPointerMove',\n    pointerout: 'onPointerOut',\n    pointerover: 'onPointerOver',\n    pointerup: 'onPointerUp',\n    wheel: 'onWheel',\n};\nexport const listenerNames = Object.keys(r3fEventToHandlerMap);\nfunction getObjectListeners(object, forEvent) {\n    if (object._listeners != null && forEvent in object._listeners) {\n        return object._listeners[forEvent];\n    }\n    //R3F compatibility\n    let handler;\n    if (object.isVoidObject && forEvent === 'click' && object.parent?.__r3f != null) {\n        handler = object.parent.__r3f.root.getState().onPointerMissed;\n    }\n    if (object.__r3f != null) {\n        handler = object.__r3f.handlers[r3fEventToHandlerMap[forEvent]];\n    }\n    if (handler == null) {\n        return undefined;\n    }\n    return [handler];\n}\n", "import { Mesh, SphereGeometry } from 'three';\nconst VoidObjectRadius = 10000000000;\nconst VoidObjectGeometry = new SphereGeometry(VoidObjectRadius);\nconst sceneVoidObjectMap = new Map();\nexport function getVoidObject(scene) {\n    let entry = sceneVoidObjectMap.get(scene);\n    if (entry == null) {\n        entry = new Mesh(VoidObjectGeometry);\n        entry.isVoidObject = true;\n        entry.parent = scene;\n        //makes sure all other intersections are always prioritized\n        entry.pointerEventsOrder = -Infinity;\n        sceneVoidObjectMap.set(scene, entry);\n    }\n    return entry;\n}\n", "import { getVoidObject } from './intersector.js';\nimport { listenerNames } from '../event.js';\nexport function computeIntersectionWorldPlane(target, intersection, objectMatrixWorld) {\n    const normal = intersection.normal ?? intersection.face?.normal;\n    if (normal == null) {\n        return false;\n    }\n    target.setFromNormalAndCoplanarPoint(normal, intersection.localPoint);\n    target.applyMatrix4(objectMatrixWorld);\n    return true;\n}\nfunction isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {\n    if (pointerEvents === 'none') {\n        return false;\n    }\n    if (pointerEvents === 'listener' && !hasListener) {\n        return false;\n    }\n    if (pointerEventsType === 'all') {\n        return true;\n    }\n    if (typeof pointerEventsType === 'function') {\n        return ({ id, type, state }) => pointerEventsType(id, type, state);\n    }\n    let value;\n    let invert;\n    if ('deny' in pointerEventsType) {\n        invert = true;\n        value = pointerEventsType.deny;\n    }\n    else {\n        invert = false;\n        value = pointerEventsType.allow;\n    }\n    if (Array.isArray(value)) {\n        return (pointer) => invertIf(value.includes(pointer.type), invert);\n    }\n    return (pointer) => invertIf(value === pointer.type, invert);\n}\nfunction invertIf(toInvert, ifIsTrue) {\n    return ifIsTrue ? !toInvert : toInvert;\n}\nexport function intersectPointerEventTargets(type, object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {\n    const hasListener = parentHasListener || hasObjectListeners(type, object);\n    const pointerEvents = object.pointerEvents ?? parentPointerEvents;\n    const pointerEventsOrDefault = pointerEvents ?? object.defaultPointerEvents ?? 'listener';\n    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? 'all';\n    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder ?? 0;\n    const isAllowed = isPointerEventsAllowed(hasListener, pointerEventsOrDefault, pointerEventsType);\n    const length = pointers.length;\n    if (length === 1) {\n        if (isAllowed === true || (typeof isAllowed === 'function' && isAllowed(pointers[0]))) {\n            filterAndInteresct(pointers[0], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    else if (isAllowed === true) {\n        for (let i = 0; i < length; i++) {\n            filterAndInteresct(pointers[i], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    else if (typeof isAllowed === 'function') {\n        for (let i = 0; i < length; i++) {\n            const pointer = pointers[i];\n            if (!isAllowed(pointer)) {\n                continue;\n            }\n            filterAndInteresct(pointer, object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    if (object.children.length === 0 || object.intersectChildren === false) {\n        return;\n    }\n    const descendants = object.interactableDescendants ?? object.children;\n    const descendantsLength = descendants.length;\n    for (let i = 0; i < descendantsLength; i++) {\n        intersectPointerEventTargets(type, descendants[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);\n    }\n}\nfunction hasObjectListeners(type, object) {\n    if (object.ancestorsHaveListeners) {\n        return true;\n    }\n    if (type === 'pointer' && object.ancestorsHavePointerListeners) {\n        return true;\n    }\n    if (type === 'wheel' && object.ancestorsHaveWheelListeners) {\n        return true;\n    }\n    if (object.__r3f != null && object.__r3f?.eventCount > 0) {\n        if (type === 'wheel' && object.__r3f['handlers']['onWheel'] != null) {\n            return true;\n        }\n        if (type === 'pointer' && Object.keys(object.__r3f['handlers']).some((key) => key != 'onWheel')) {\n            return true;\n        }\n    }\n    if (object._listeners == null) {\n        return false;\n    }\n    if (type === 'wheel') {\n        const wheelListeners = object._listeners.wheel;\n        return wheelListeners != null && wheelListeners.length > 0;\n    }\n    const entries = Object.entries(object._listeners);\n    const length = entries.length;\n    for (let i = 0; i < length; i++) {\n        const entry = entries[i];\n        if (entry[0] === 'wheel') {\n            continue;\n        }\n        if (!listenerNames.includes(entry[0])) {\n            continue;\n        }\n        if (entry[1] != null && entry[1].length > 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction filterAndInteresct({ intersector, options }, object, pointerEvents, pointerEventsType, pointerEventsOrder) {\n    if (options.filter?.(object, pointerEvents, pointerEventsType, pointerEventsOrder) === false) {\n        return;\n    }\n    intersector.executeIntersection(object, pointerEventsOrder);\n}\n/**\n * @returns undefined if `i1` is the dominant intersection\n * @param i2DistanceOffset modifies i2 and adds the i2DistanceOffset to the current distance\n */\nexport function getDominantIntersectionIndex(intersections, pointerEventsOrders, { customSort: compare = defaultSort } = {}, filter) {\n    let intersection = undefined;\n    let pointerEventsOrder = undefined;\n    let index = undefined;\n    const length = intersections.length;\n    for (let i = 0; i < length; i++) {\n        const newIntersection = intersections[i];\n        if (filter?.(newIntersection) === false) {\n            continue;\n        }\n        const newPointerEventsOrder = pointerEventsOrders?.[i];\n        if (intersection == null || compare(newIntersection, newPointerEventsOrder, intersection, pointerEventsOrder) < 0) {\n            index = i;\n            intersection = newIntersection;\n            pointerEventsOrder = newPointerEventsOrder;\n        }\n    }\n    return index;\n}\n/**\n * @returns a negative number if i1 should be sorted before i2\n */\nfunction defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {\n    if (pointerEventsOrder1 != pointerEventsOrder2) {\n        //inverted order because order is sorted highest first\n        return pointerEventsOrder2 - pointerEventsOrder1;\n    }\n    //i1 - i2 because negative values mean the sorting i1 before i2 is correct\n    return i1.distance - i2.distance;\n}\nconst VoidObjectDistance = 10000000;\nexport function voidObjectIntersectionFromRay(scene, ray, getDetails, pointerPosition, pointerQuaternion, addToDistance = 0) {\n    const point = ray.direction.clone().multiplyScalar(VoidObjectDistance);\n    const distanceOnRay = VoidObjectDistance;\n    return {\n        distance: distanceOnRay + addToDistance,\n        object: getVoidObject(scene),\n        point,\n        normal: ray.origin.clone().sub(point).normalize(),\n        details: getDetails(point, distanceOnRay),\n        pointerPosition,\n        pointerQuaternion,\n        pointOnFace: point,\n        localPoint: point,\n    };\n}\nexport function pushTimes(target, value, times) {\n    while (times > 0) {\n        target.push(value);\n        --times;\n    }\n}\n", "import { Object3D } from 'three';\nimport { PointerEvent, WheelEvent, emitPointerEvent } from './event.js';\nimport { intersectPointerEventTargets } from './intersections/utils.js';\nconst buttonsDownTimeKey = Symbol('buttonsDownTime');\nconst buttonsClickTimeKey = Symbol('buttonsClickTime');\nglobalThis.pointerEventspointerMap ??= new Map();\nObject3D.prototype.setPointerCapture = function (pointerId) {\n    getPointerById(pointerId)?.setCapture(this);\n};\nObject3D.prototype.releasePointerCapture = function (pointerId) {\n    const pointer = getPointerById(pointerId);\n    if (pointer == null || !pointer.hasCaptured(this)) {\n        return;\n    }\n    pointer.setCapture(undefined);\n};\nObject3D.prototype.hasPointerCapture = function (pointerId) {\n    return getPointerById(pointerId)?.hasCaptured(this) ?? false;\n};\nexport function getPointerById(pointerId) {\n    return globalThis.pointerEventspointerMap?.get(pointerId);\n}\nexport class Pointer {\n    id;\n    type;\n    state;\n    intersector;\n    getCamera;\n    onMoveCommited;\n    parentSetPointerCapture;\n    parentReleasePointerCapture;\n    options;\n    //state\n    prevIntersection;\n    intersection;\n    prevEnabled = true;\n    enabled = true;\n    wheelIntersection;\n    //derived state\n    /**\n     * ordered leaf -> root (bottom -> top)\n     */\n    pointerEntered = [];\n    pointerEnteredHelper = [];\n    pointerCapture;\n    buttonsDownTime = new Map();\n    buttonsDown = new Set();\n    //to handle interaction before first move (after exit)\n    wasMoved = false;\n    onFirstMove = [];\n    constructor(id, type, state, intersector, getCamera, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {\n        this.id = id;\n        this.type = type;\n        this.state = state;\n        this.intersector = intersector;\n        this.getCamera = getCamera;\n        this.onMoveCommited = onMoveCommited;\n        this.parentSetPointerCapture = parentSetPointerCapture;\n        this.parentReleasePointerCapture = parentReleasePointerCapture;\n        this.options = options;\n        globalThis.pointerEventspointerMap?.set(id, this);\n    }\n    getPointerCapture() {\n        return this.pointerCapture;\n    }\n    hasCaptured(object) {\n        return this.pointerCapture?.object === object;\n    }\n    setCapture(object) {\n        if (this.pointerCapture?.object === object) {\n            return;\n        }\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        if (object != null && this.intersection != null) {\n            this.pointerCapture = { object, intersection: this.intersection };\n            this.parentSetPointerCapture?.();\n        }\n    }\n    getButtonsDown() {\n        return this.buttonsDown;\n    }\n    /**\n     * @returns undefined if no intersection was executed yet\n     */\n    getIntersection() {\n        return this.intersection;\n    }\n    getEnabled() {\n        return this.enabled;\n    }\n    setEnabled(enabled, nativeEvent, commit = true) {\n        if (this.enabled === enabled) {\n            return;\n        }\n        if (!enabled && this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.enabled = enabled;\n        if (commit) {\n            this.commit(nativeEvent, false);\n        }\n    }\n    computeIntersection(type, scene, nativeEvent) {\n        if (this.pointerCapture != null) {\n            return this.intersector.intersectPointerCapture(this.pointerCapture, nativeEvent);\n        }\n        this.intersector.startIntersection(nativeEvent);\n        intersectPointerEventTargets(type, scene, [this]);\n        return this.intersector.finalizeIntersection(scene);\n    }\n    setIntersection(intersection) {\n        this.intersection = intersection;\n    }\n    commit(nativeEvent, emitMove) {\n        const camera = this.getCamera();\n        const prevIntersection = this.prevEnabled ? this.prevIntersection : undefined;\n        const intersection = this.enabled ? this.intersection : undefined;\n        //pointer out\n        if (prevIntersection != null && prevIntersection.object != intersection?.object) {\n            emitPointerEvent(new PointerEvent('pointerout', true, nativeEvent, this, prevIntersection, camera));\n        }\n        const pointerLeft = this.pointerEntered;\n        this.pointerEntered = [];\n        this.pointerEnteredHelper.length = 0;\n        computeEnterLeave(intersection?.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);\n        //pointerleave\n        const length = pointerLeft.length;\n        for (let i = 0; i < length; i++) {\n            const object = pointerLeft[i];\n            emitPointerEvent(new PointerEvent('pointerleave', false, nativeEvent, this, prevIntersection, camera, object));\n        }\n        //pointer over\n        if (intersection != null && prevIntersection?.object != intersection.object) {\n            emitPointerEvent(new PointerEvent('pointerover', true, nativeEvent, this, intersection, camera));\n        }\n        //pointer enter\n        //inverse loop so that we emit enter from top -> bottom (root -> leaf)\n        for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {\n            const object = this.pointerEnteredHelper[i];\n            emitPointerEvent(new PointerEvent('pointerenter', false, nativeEvent, this, intersection, camera, object));\n        }\n        //pointer move\n        if (emitMove && intersection != null) {\n            emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, intersection, camera));\n        }\n        this.prevIntersection = this.intersection;\n        this.prevEnabled = this.enabled;\n        if (!this.wasMoved && this.intersector.isReady()) {\n            this.wasMoved = true;\n            const length = this.onFirstMove.length;\n            for (let i = 0; i < length; i++) {\n                this.onFirstMove[i](camera);\n            }\n            this.onFirstMove.length = 0;\n        }\n        this.onMoveCommited?.(this);\n    }\n    /**\n     * computes and commits a move\n     */\n    move(scene, nativeEvent) {\n        this.intersection = this.computeIntersection('pointer', scene, nativeEvent);\n        this.commit(nativeEvent, true);\n    }\n    /**\n     * computes and commits the pointer if a move has not yet occured\n     */\n    over(scene, nativeEvent) {\n        if (!this.wasMoved) {\n            this.intersection = this.computeIntersection('pointer', scene, nativeEvent);\n            this.commit(nativeEvent, false);\n        }\n    }\n    /**\n     * emits a move without (re-)computing the intersection\n     * just emitting a move event to the current intersection\n     */\n    emitMove(nativeEvent) {\n        if (this.intersection == null) {\n            return;\n        }\n        emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, this.intersection, this.getCamera()));\n    }\n    down(nativeEvent) {\n        this.buttonsDown.add(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.down.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer down\n        emitPointerEvent(new PointerEvent('pointerdown', true, nativeEvent, this, this.intersection, this.getCamera()));\n        //store button down times on object and on pointer\n        const { object } = this.intersection;\n        object[buttonsDownTimeKey] ??= new Map();\n        object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);\n        this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);\n    }\n    up(nativeEvent) {\n        this.buttonsDown.delete(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.up.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        const { clickThesholdMs, contextMenuButton = 2, dblClickThresholdMs = 500, clickThresholdMs = clickThesholdMs ?? 300, } = this.options;\n        this.pointerCapture = undefined;\n        const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThresholdMs);\n        const camera = this.getCamera();\n        //context menu\n        if (isClicked && nativeEvent.button === contextMenuButton) {\n            emitPointerEvent(new PointerEvent('contextmenu', true, nativeEvent, this, this.intersection, camera));\n        }\n        //poinerup\n        emitPointerEvent(new PointerEvent('pointerup', true, nativeEvent, this, this.intersection, camera));\n        if (!isClicked || nativeEvent.button === contextMenuButton) {\n            return;\n        }\n        //click\n        emitPointerEvent(new PointerEvent('click', true, nativeEvent, this, this.intersection, camera));\n        //dblclick\n        const { object } = this.intersection;\n        const buttonsClickTime = (object[buttonsClickTimeKey] ??= new Map());\n        const buttonClickTime = buttonsClickTime.get(nativeEvent.button);\n        if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {\n            buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);\n            return;\n        }\n        emitPointerEvent(new PointerEvent('dblclick', true, nativeEvent, this, this.intersection, camera));\n        buttonsClickTime.delete(nativeEvent.button);\n    }\n    cancel(nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer cancel\n        emitPointerEvent(new PointerEvent('pointercancel', true, nativeEvent, this, this.intersection, this.getCamera()));\n    }\n    wheel(scene, nativeEvent, useMoveIntersection = false) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved && useMoveIntersection) {\n            this.onFirstMove.push(this.wheel.bind(this, scene, nativeEvent, useMoveIntersection));\n            return;\n        }\n        if (!useMoveIntersection) {\n            this.wheelIntersection = this.computeIntersection('wheel', scene, nativeEvent);\n        }\n        const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));\n    }\n    emitWheel(nativeEvent, useMoveIntersection = false) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved && useMoveIntersection) {\n            this.onFirstMove.push(this.emitWheel.bind(this, nativeEvent, useMoveIntersection));\n            return;\n        }\n        const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));\n    }\n    exit(nativeEvent) {\n        if (this.wasMoved) {\n            //reset state\n            if (this.pointerCapture != null) {\n                this.parentReleasePointerCapture?.();\n                this.pointerCapture = undefined;\n            }\n            this.intersection = undefined;\n            this.commit(nativeEvent, false);\n        }\n        this.onFirstMove.length = 0;\n        this.wasMoved = false;\n    }\n}\n/**\n * @returns an array that contains the object and all its ancestors ordered leaf -> root (bottom -> top)\n */\nfunction computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {\n    if (currentObject == null) {\n        return;\n    }\n    const index = targeDiffRemovedAncestors.indexOf(currentObject);\n    if (index != -1) {\n        targeDiffRemovedAncestors.splice(index, 1);\n    }\n    else {\n        targetDiffAddedAncestors.push(currentObject);\n    }\n    targetAllAncestors.push(currentObject);\n    computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);\n}\nfunction getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThresholdMs) {\n    if (objectButtonsDownTime == null) {\n        return false;\n    }\n    const objectButtonPressTime = objectButtonsDownTime.get(button);\n    if (objectButtonPressTime == null) {\n        return false;\n    }\n    if (buttonUpTime - objectButtonPressTime > clickThresholdMs) {\n        return false;\n    }\n    if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {\n        //we have released the button somewhere else\n        return false;\n    }\n    return true;\n}\n", "import { BufferAttribute, Matrix4, Triangle, Vector2, Vector3 } from 'three';\nexport function updateAndCheckWorldTransformation(object) {\n    if (object.transformReady === false) {\n        return false;\n    }\n    if (object.parent == null) {\n        object.matrixWorld.copy(object.matrix);\n        return true;\n    }\n    if (!updateAndCheckWorldTransformation(object.parent)) {\n        return false;\n    }\n    //we can just use parent.matrixWorld here because we already executed `updateAndCheckWorldTransformation` before which has updated parent.matrixWorld\n    object.matrixWorld.multiplyMatrices(object.parent.matrixWorld, object.matrix);\n    return true;\n}\nconst triangleHelper1 = new Triangle();\nconst triangleHelper2 = new Triangle();\nconst aVec2Helper = new Vector2();\nconst bVec2Helper = new Vector2();\nconst cVec2Helper = new Vector2();\nconst pointHelper = new Vector3();\nconst inverseMatrix = new Matrix4();\nconst localPointHelper = new Vector3();\n/**\n * @requires that `mesh.updateWorldMatrix(true, false)` was executed beforehand\n */\nexport function getClosestUV(target, point, mesh) {\n    localPointHelper.copy(point).applyMatrix4(inverseMatrix.copy(mesh.matrixWorld).invert());\n    const uv = mesh.geometry.attributes.uv;\n    if (uv == null || !(uv instanceof BufferAttribute)) {\n        return false;\n    }\n    let clostestDistance;\n    loopThroughTriangles(mesh, (i1, i2, i3) => {\n        mesh.getVertexPosition(i1, triangleHelper1.a);\n        mesh.getVertexPosition(i2, triangleHelper1.b);\n        mesh.getVertexPosition(i3, triangleHelper1.c);\n        const distance = triangleHelper1.closestPointToPoint(localPointHelper, pointHelper).distanceTo(localPointHelper);\n        if (clostestDistance != null && distance >= clostestDistance) {\n            return;\n        }\n        clostestDistance = distance;\n        triangleHelper2.copy(triangleHelper1);\n        aVec2Helper.fromBufferAttribute(uv, i1);\n        bVec2Helper.fromBufferAttribute(uv, i2);\n        cVec2Helper.fromBufferAttribute(uv, i3);\n    });\n    if (clostestDistance == null) {\n        return false;\n    }\n    triangleHelper2.closestPointToPoint(localPointHelper, pointHelper);\n    triangleHelper2.getInterpolation(pointHelper, aVec2Helper, bVec2Helper, cVec2Helper, target);\n    return true;\n}\nfunction loopThroughTriangles(mesh, fn) {\n    const drawRange = mesh.geometry.drawRange;\n    if (mesh.geometry.index != null) {\n        const index = mesh.geometry.index;\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start; i < end; i += 3) {\n            fn(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n        return;\n    }\n    const position = mesh.geometry.attributes.position;\n    if (position == null) {\n        return;\n    }\n    const start = Math.max(0, drawRange.start);\n    const end = Math.min(position.count, drawRange.start + drawRange.count);\n    for (let i = start; i < end; i += 3) {\n        fn(i, i + 1, i + 2);\n    }\n}\n", "import { Line3, Matrix4, Plane, Quaternion, Ray, Raycaster, Vector3, Mesh, Vector2, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, pushTimes, voidObjectIntersectionFromRay, } from './utils.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst invertedMatrixHelper = new Matrix4();\nconst lineHelper = new Line3();\nconst scaleHelper = new Vector3();\nconst planeHelper = new Plane();\nconst rayHelper = new Ray();\nconst point2Helper = new Vector2();\nconst defaultLinePoints = [new Vector3(0, 0, 0), new Vector3(0, 0, 1)];\nexport class LinesIntersector {\n    space;\n    options;\n    raycasters = [];\n    fromMatrixWorld = new Matrix4();\n    ready;\n    intersects = [];\n    pointerEventsOrders = [];\n    raycasterIndices = [];\n    constructor(space, options) {\n        this.space = space;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        this.fromMatrixWorld.copy(spaceObject.matrixWorld);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        const details = intersection.details;\n        if (details.type != 'lines') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a lines intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(this.fromMatrixWorld);\n        const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const pointOnFace = rayHelper.intersectPlane(planeHelper, new Vector3()) ?? point;\n        const pointerPosition = new Vector3();\n        const pointerQuaternion = new Quaternion();\n        this.fromMatrixWorld.decompose(pointerPosition, pointerQuaternion, scaleHelper);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            object,\n            uv,\n            pointOnFace,\n            point,\n            pointerPosition,\n            pointerQuaternion,\n        };\n    }\n    startIntersection() {\n        if (!this.prepareTransformation()) {\n            return;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        const length = linePoints.length - 1;\n        for (let i = 0; i < length; i++) {\n            const start = linePoints[i];\n            const end = linePoints[i + 1];\n            const raycaster = this.raycasters[i] ?? (this.raycasters[i] = new Raycaster());\n            //transform from local object to world\n            raycaster.ray.origin.copy(start).applyMatrix4(this.fromMatrixWorld);\n            raycaster.ray.direction.copy(end).applyMatrix4(this.fromMatrixWorld);\n            //compute length & normalized direction\n            raycaster.ray.direction.sub(raycaster.ray.origin);\n            const lineLength = raycaster.ray.direction.length();\n            raycaster.ray.direction.divideScalar(lineLength);\n            raycaster.far = lineLength;\n        }\n        this.raycasters.length = length;\n        return;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        if (!this.isReady()) {\n            return;\n        }\n        const startOuter = this.intersects.length;\n        const length = this.raycasters.length;\n        for (let i = 0; i < length; i++) {\n            const raycaster = this.raycasters[i];\n            const startInner = this.intersects.length;\n            object.raycast(raycaster, this.intersects);\n            pushTimes(this.raycasterIndices, i, this.intersects.length - startInner);\n        }\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - startOuter);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = new Vector3().setFromMatrixPosition(this.fromMatrixWorld);\n        const pointerQuaternion = new Quaternion().setFromRotationMatrix(this.fromMatrixWorld);\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        const raycasterIndex = index == null ? undefined : this.raycasterIndices[index];\n        this.intersects.length = 0;\n        this.raycasterIndices.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null || raycasterIndex == null) {\n            const lastRaycasterIndex = this.raycasters.length - 1;\n            const prevDistance = this.raycasters.reduce((prev, caster, i) => (i === lastRaycasterIndex ? prev : prev + caster.far), 0);\n            const lastRaycaster = this.raycasters[lastRaycasterIndex];\n            return voidObjectIntersectionFromRay(scene, lastRaycaster.ray, (point, distanceOnLine) => ({\n                line: new Line3(lastRaycaster.ray.origin.clone(), point),\n                lineIndex: this.raycasters.length - 1,\n                distanceOnLine,\n                type: 'lines',\n            }), pointerPosition, pointerQuaternion, prevDistance);\n        }\n        let distance = intersection.distance;\n        for (let i = 0; i < raycasterIndex; i++) {\n            distance += this.raycasters[i].far;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        //TODO: consider maxLength\n        const raycaster = this.raycasters[raycasterIndex];\n        return Object.assign(intersection, {\n            details: {\n                lineIndex: raycasterIndex,\n                distanceOnLine: intersection.distance,\n                type: 'lines',\n                line: new Line3(raycaster.ray.origin.clone(), raycaster.ray.direction.clone().multiplyScalar(raycaster.far).add(raycaster.ray.origin)),\n            },\n            distance,\n            pointerPosition,\n            pointerQuaternion,\n            pointOnFace: intersection.point,\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\n", "import { Matrix4, Plane, Quaternion, Raycaster, Vector3, Vector2, Mesh, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, pushTimes, voidObjectIntersectionFromRay, } from './utils.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst invertedMatrixHelper = new Matrix4();\nconst scaleHelper = new Vector3();\nconst NegZAxis = new Vector3(0, 0, -1);\nconst planeHelper = new Plane();\nconst point2Helper = new Vector2();\nexport class RayIntersector {\n    space;\n    options;\n    raycaster = new Raycaster();\n    raycasterQuaternion = new Quaternion();\n    worldScale = 0;\n    ready;\n    intersects = [];\n    pointerEventsOrders = [];\n    constructor(space, options) {\n        this.space = space;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        spaceObject.matrixWorld.decompose(this.raycaster.ray.origin, this.raycasterQuaternion, scaleHelper);\n        this.worldScale = scaleHelper.x;\n        this.raycaster.ray.direction.copy(this.options?.direction ?? NegZAxis).applyQuaternion(this.raycasterQuaternion);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        if (intersection.details.type != 'ray') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a ray intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const { ray } = this.raycaster;\n        const pointOnFace = ray.intersectPlane(planeHelper, new Vector3()) ?? intersection.point;\n        const point = ray.direction\n            .clone()\n            .multiplyScalar(intersection.pointerPosition.distanceTo(intersection.point))\n            .add(ray.origin);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            uv,\n            object,\n            pointOnFace,\n            point,\n            pointerPosition: ray.origin.clone(),\n            pointerQuaternion: this.raycasterQuaternion.clone(),\n        };\n    }\n    startIntersection() {\n        this.prepareTransformation();\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        if (!this.isReady()) {\n            return;\n        }\n        const start = this.intersects.length;\n        object.raycast(this.raycaster, this.intersects);\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.raycaster.ray.origin.clone();\n        const pointerQuaternion = this.raycasterQuaternion.clone();\n        let filter;\n        if (this.options.minDistance != null) {\n            const localMinDistance = this.options.minDistance / this.worldScale;\n            filter = (intersection) => intersection.distance >= localMinDistance;\n        }\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options, filter);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null) {\n            return voidObjectIntersectionFromRay(scene, this.raycaster.ray, () => ({ type: 'ray' }), pointerPosition, pointerQuaternion);\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        return Object.assign(intersection, {\n            details: {\n                type: 'ray',\n            },\n            pointerPosition,\n            pointerQuaternion,\n            pointOnFace: intersection.point,\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nconst directionHelper = new Vector3();\nexport class ScreenRayIntersector {\n    prepareTransformation;\n    options;\n    raycaster = new Raycaster();\n    cameraQuaternion = new Quaternion();\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    coords = new Vector2();\n    viewPlane = new Plane();\n    intersects = [];\n    pointerEventsOrders = [];\n    constructor(prepareTransformation, options) {\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    isReady() {\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        const details = intersection.details;\n        if (details.type != 'screen-ray') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a camera ray intersector`);\n        }\n        if (!this.startIntersection(nativeEvent)) {\n            return intersection;\n        }\n        this.viewPlane.constant -= details.distanceViewPlane;\n        //find captured intersection point by intersecting the ray to the plane of the camera\n        const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());\n        if (point == null) {\n            return intersection;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(this.viewPlane, intersection, intersection.object.matrixWorld);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            details: {\n                ...details,\n                direction: this.raycaster.ray.direction.clone(),\n                screenPoint: this.coords.clone(),\n            },\n            uv,\n            object,\n            point,\n            pointOnFace: point,\n            pointerPosition: this.raycaster.ray.origin.clone(),\n            pointerQuaternion: this.cameraQuaternion.clone(),\n        };\n    }\n    startIntersection(nativeEvent) {\n        const from = this.prepareTransformation(nativeEvent, this.coords);\n        if (from == null) {\n            return false;\n        }\n        from.updateWorldMatrix(true, false);\n        from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);\n        this.raycaster.setFromCamera(this.coords, from);\n        this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        const start = this.intersects.length;\n        object.raycast(this.raycaster, this.intersects);\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.fromPosition.clone();\n        const pointerQuaternion = this.cameraQuaternion.clone();\n        const pointerDirection = this.raycaster.ray.direction.clone();\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null) {\n            return voidObjectIntersectionFromRay(scene, this.raycaster.ray, (_point, distance) => ({\n                type: 'screen-ray',\n                distanceViewPlane: distance,\n                screenPoint: this.coords.clone(),\n                direction: pointerDirection,\n            }), pointerPosition, pointerQuaternion);\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        invertedMatrixHelper.copy(intersection.object.matrixWorld).invert();\n        return Object.assign(intersection, {\n            details: {\n                type: 'screen-ray',\n                distanceViewPlane: this.viewPlane.distanceToPoint(intersection.point),\n                screenPoint: this.coords.clone(),\n                direction: pointerDirection,\n            },\n            pointOnFace: intersection.point,\n            pointerPosition,\n            pointerQuaternion,\n            localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper),\n        });\n    }\n}\n", "import { PointerEvent } from './event.js';\nimport { ScreenRayIntersector } from './intersections/ray.js';\nimport { generateUniquePointerId } from './pointer/index.js';\nimport { Pointer } from './pointer.js';\nfunction htmlEventToCoords(element, e, target) {\n    if (!(e instanceof globalThis.MouseEvent)) {\n        return target.set(0, 0);\n    }\n    const { width, height, top, left } = element.getBoundingClientRect();\n    const x = e.clientX - left;\n    const y = e.clientY - top;\n    return target.set((x / width) * 2 - 1, -(y / height) * 2 + 1);\n}\n/**\n * sets the `pointerTypePrefix` to `\"screen-\"`. Therefore, a event with pointerType `touch` is forwarded to the scene as `\"screen-touch\"`\n */\nexport function forwardHtmlEvents(fromElement, getCamera, scene, options) {\n    return forwardEvents(fromElement, \n    //backwards compatibility\n    typeof getCamera === 'function' ? getCamera : () => getCamera, scene, htmlEventToCoords.bind(null, fromElement), fromElement.setPointerCapture.bind(fromElement), (pointerId) => {\n        if (fromElement.hasPointerCapture(pointerId)) {\n            fromElement.releasePointerCapture(pointerId);\n        }\n    }, {\n        pointerTypePrefix: 'screen-',\n        ...options,\n    });\n}\nfunction portalEventToCoords(e, target) {\n    if (!(e instanceof PointerEvent)) {\n        return target.set(0, 0);\n    }\n    if (e.uv == null) {\n        return target.set(0, 0);\n    }\n    return target.copy(e.uv).multiplyScalar(2).addScalar(-1);\n}\nexport function forwardObjectEvents(fromPortal, getCamera, scene, options) {\n    return forwardEvents(fromPortal, getCamera, scene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);\n}\n/**\n * @returns cleanup function\n */\nfunction forwardEvents(from, getCamera, scene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {\n    const forwardPointerCapture = options?.forwardPointerCapture ?? true;\n    const pointerMap = new Map();\n    const pointerTypePrefix = options.pointerTypePrefix ?? 'forward-';\n    const getInnerPointer = (event, eventType) => {\n        let innerPointer = pointerMap.get(event.pointerId);\n        if (innerPointer != null) {\n            return innerPointer;\n        }\n        innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${event.pointerType}`, event.pointerState, new ScreenRayIntersector((nativeEvent, coords) => {\n            toCoords(nativeEvent, coords);\n            return getCamera();\n        }, options), getCamera, undefined, forwardPointerCapture ? setPointerCapture.bind(null, event.pointerId) : undefined, forwardPointerCapture ? releasePointerCapture.bind(null, event.pointerId) : undefined, options);\n        if (eventType != 'move' && eventType != 'wheel') {\n            //if we start with a non-move event no, we intersect and commit\n            //this allows enter, down, ... events to be forwarded to the scene even when they dont come with a move event\n            innerPointer.setIntersection(innerPointer.computeIntersection('pointer', scene, event));\n            innerPointer.commit(event, false);\n        }\n        pointerMap.set(event.pointerId, innerPointer);\n        return innerPointer;\n    };\n    const latestWheelEventMap = new Map();\n    const latestMoveEventMap = new Map();\n    const movedPointerList = [];\n    const eventList = [];\n    const emitEvent = (type, event, pointer) => {\n        switch (type) {\n            case 'move':\n                pointer.move(scene, event);\n                return;\n            case 'over':\n                pointer.move(scene, event);\n                return;\n            case 'wheel':\n                pointer.wheel(scene, event);\n                return;\n            case 'cancel':\n                pointer.cancel(event);\n                return;\n            case 'down':\n                if (!hasButton(event)) {\n                    return;\n                }\n                pointer.down(event);\n                return;\n            case 'up':\n                if (!hasButton(event)) {\n                    return;\n                }\n                pointer.up(event);\n                return;\n            case 'exit':\n                latestMoveEventMap.delete(pointer);\n                latestWheelEventMap.delete(pointer);\n                pointer.exit(event);\n                return;\n        }\n    };\n    const onEvent = (type, event) => {\n        const pointer = getInnerPointer(event, type);\n        if (type === 'move') {\n            latestMoveEventMap.set(pointer, event);\n        }\n        if (type === 'wheel') {\n            latestWheelEventMap.set(pointer, event);\n        }\n        if (options.batchEvents ?? true) {\n            eventList.push({ type, event });\n        }\n        else {\n            emitEvent(type, event, pointer);\n        }\n    };\n    const pointerMoveListener = onEvent.bind(null, 'move');\n    const pointerOverListener = onEvent.bind(null, 'over');\n    const pointerCancelListener = onEvent.bind(null, 'cancel');\n    const pointerDownListener = onEvent.bind(null, 'down');\n    const pointerUpListener = onEvent.bind(null, 'up');\n    const wheelListener = onEvent.bind(null, 'wheel');\n    const pointerLeaveListener = onEvent.bind(null, 'exit');\n    from.addEventListener('pointermove', pointerMoveListener);\n    from.addEventListener('pointerover', pointerOverListener);\n    from.addEventListener('pointercancel', pointerCancelListener);\n    from.addEventListener('pointerdown', pointerDownListener);\n    from.addEventListener('pointerup', pointerUpListener);\n    from.addEventListener('wheel', wheelListener);\n    from.addEventListener('pointerleave', pointerLeaveListener);\n    return {\n        destroy() {\n            from.removeEventListener('pointermove', pointerMoveListener);\n            from.removeEventListener('pointerover', pointerOverListener);\n            from.removeEventListener('pointercancel', pointerCancelListener);\n            from.removeEventListener('pointerdown', pointerDownListener);\n            from.removeEventListener('pointerup', pointerUpListener);\n            from.removeEventListener('wheel', wheelListener);\n            from.removeEventListener('pointerleave', pointerLeaveListener);\n            latestMoveEventMap.clear();\n            latestWheelEventMap.clear();\n        },\n        update() {\n            const length = eventList.length;\n            for (let i = 0; i < length; i++) {\n                const { type, event } = eventList[i];\n                const pointer = getInnerPointer(event, type);\n                if (type === 'move') {\n                    movedPointerList.push(pointer);\n                    if (latestMoveEventMap.get(pointer) != event) {\n                        //not the last move => move wihout recomputing the intersection\n                        pointer.emitMove(event);\n                        continue;\n                    }\n                }\n                if (type === 'wheel' && latestWheelEventMap.get(pointer) != event) {\n                    pointer.emitWheel(event);\n                    continue;\n                }\n                emitEvent(type, event, pointer);\n            }\n            eventList.length = 0;\n            if (options.intersectEveryFrame ?? false) {\n                for (const [pointer, event] of latestMoveEventMap.entries()) {\n                    if (movedPointerList.includes(pointer)) {\n                        continue;\n                    }\n                    pointer.move(scene, event);\n                }\n            }\n            movedPointerList.length = 0;\n        },\n    };\n}\nfunction hasButton(val) {\n    return val.button != null;\n}\n", "import { intersectPointerEventTargets } from './intersections/utils.js';\nexport class CombinedPointer {\n    enableMultiplePointers;\n    pointers = [];\n    isDefaults = [];\n    enabled = true;\n    activePointer;\n    nonCapturedPointers = [];\n    constructor(enableMultiplePointers) {\n        this.enableMultiplePointers = enableMultiplePointers;\n    }\n    register(pointer, isDefault = false) {\n        this.pointers.push(pointer);\n        this.isDefaults.push(isDefault);\n        return this.unregister.bind(this, pointer);\n    }\n    unregister(pointer) {\n        const index = this.pointers.indexOf(pointer);\n        if (index === -1) {\n            return;\n        }\n        this.isDefaults.splice(index, 1);\n        this.pointers.splice(index, 1);\n    }\n    /**\n     * @returns true if any pointer is captured\n     */\n    startIntersection(nonCapturedPointers, nativeEvent) {\n        const length = this.pointers.length;\n        let anyPointerIsCaptured = false;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.startIntersection(nonCapturedPointers, nativeEvent);\n                continue;\n            }\n            const pointerCapture = pointer.getPointerCapture();\n            if (pointerCapture != null) {\n                anyPointerIsCaptured = true;\n                pointer.setIntersection(pointer.intersector.intersectPointerCapture(pointerCapture, nativeEvent));\n                continue;\n            }\n            nonCapturedPointers.push(pointer);\n            pointer.intersector.startIntersection(nativeEvent);\n        }\n        return anyPointerIsCaptured;\n    }\n    /**\n     * only for internal use\n     */\n    getIntersection() {\n        return this.activePointer?.getIntersection();\n    }\n    /**\n     * only for internal use\n     */\n    getPointerCapture() {\n        return this.activePointer?.getPointerCapture();\n    }\n    computeActivePointer() {\n        let smallestDistance;\n        this.activePointer = undefined;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.computeActivePointer();\n            }\n            const intersection = pointer.getIntersection();\n            const distance = pointer.getPointerCapture() != null\n                ? -Infinity\n                : intersection?.object.isVoidObject\n                    ? Infinity\n                    : (intersection?.distance ?? Infinity);\n            const isDefault = this.isDefaults[i];\n            if (smallestDistance == null || (isDefault && distance === smallestDistance) || distance < smallestDistance) {\n                this.activePointer = pointer;\n                smallestDistance = distance;\n            }\n        }\n    }\n    /**\n     * only for internal use\n     */\n    commit(nativeEvent, emitMove, computeActivePointer = true) {\n        if (this.enableMultiplePointers) {\n            const length = this.pointers.length;\n            for (let i = 0; i < length; i++) {\n                this.pointers[i].commit(nativeEvent, emitMove);\n            }\n            return;\n        }\n        if (computeActivePointer) {\n            this.computeActivePointer();\n        }\n        //commit all pointers, enable the active pointer, and disable all other pointers\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(pointer === this.activePointer, nativeEvent, false);\n            pointer.commit(nativeEvent, emitMove, false);\n        }\n    }\n    move(scene, nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        //start intersection, build nonCapturedPointers list, and compute the intersection for all captured pointers\n        this.nonCapturedPointers.length = 0;\n        const anyPointerIsCaptured = this.startIntersection(this.nonCapturedPointers, nativeEvent);\n        //we only need to intersect the scene if no pointer is captured or (in case one or more pointers are captured) if mulitple pointers can be enabled\n        if (!anyPointerIsCaptured || this.enableMultiplePointers) {\n            //intersect scene using the non captured pointers\n            intersectPointerEventTargets('pointer', scene, this.nonCapturedPointers);\n            //finalize the intersection for the non captured pointers\n            const nonCapturedPointerLength = this.nonCapturedPointers.length;\n            for (let i = 0; i < nonCapturedPointerLength; i++) {\n                const pointer = this.nonCapturedPointers[i];\n                pointer.setIntersection(pointer.intersector.finalizeIntersection(scene));\n            }\n        }\n        //commit the intersection, compute active pointers, and enabling/disabling pointers\n        this.commit(nativeEvent, true);\n    }\n    setEnabled(enabled, nativeEvent) {\n        this.enabled = enabled;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(enabled && (this.enableMultiplePointers || pointer == this.activePointer), nativeEvent);\n        }\n    }\n}\n", "import { InstancedMesh, Matrix4, Mesh, Vector3, Sphere, Quaternion, Plane, Vector2, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';\nimport { getVoidObject } from '../index.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst scaleHelper = new Vector3();\nconst point2Helper = new Vector2();\nexport class SphereIntersector {\n    space;\n    getSphereRadius;\n    options;\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    collisionSphere = new Sphere();\n    ready;\n    intersects = [];\n    constructor(space, getSphereRadius, options) {\n        this.space = space;\n        this.getSphereRadius = getSphereRadius;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        spaceObject.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        if (intersection.details.type != 'sphere') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a sphere intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        //compute old inputDevicePosition-point offset\n        oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);\n        //compute oldInputDeviceQuaternion-newInputDeviceQuaternion offset\n        inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(this.fromQuaternion);\n        //apply quaternion offset to old inputDevicePosition-point offset and add to new inputDevicePosition\n        const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(this.fromPosition);\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const pointOnFace = planeHelper.projectPoint(this.fromPosition, new Vector3());\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            details: {\n                type: 'sphere',\n            },\n            uv,\n            distance: point.distanceTo(pointOnFace),\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            object,\n            point,\n            pointOnFace,\n            face: intersection.face,\n            localPoint: intersection.localPoint,\n        };\n    }\n    startIntersection() {\n        if (!this.prepareTransformation()) {\n            return;\n        }\n        this.collisionSphere.center.copy(this.fromPosition);\n        this.collisionSphere.radius = this.getSphereRadius();\n    }\n    executeIntersection(object) {\n        if (!this.isReady()) {\n            return;\n        }\n        intersectSphereWithObject(this.collisionSphere, object, this.intersects);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.fromPosition.clone();\n        const pointerQuaternion = this.fromQuaternion.clone();\n        const index = getDominantIntersectionIndex(this.intersects, undefined, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        if (intersection == null) {\n            return {\n                details: {\n                    type: 'sphere',\n                },\n                distance: 0,\n                point: pointerPosition,\n                object: getVoidObject(scene),\n                pointerPosition,\n                pointerQuaternion,\n                pointOnFace: pointerPosition,\n                localPoint: pointerPosition,\n            };\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        return Object.assign(intersection, {\n            details: {\n                type: 'sphere',\n            },\n            pointOnFace: intersection.point,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nconst matrixHelper = new Matrix4();\nfunction intersectSphereWithObject(pointerSphere, object, target) {\n    object.updateWorldMatrix(true, false);\n    if (object.spherecast != null) {\n        object.spherecast(pointerSphere, target);\n        return;\n    }\n    if (object instanceof InstancedMesh) {\n        if (object.geometry.boundingSphere == null) {\n            object.geometry.computeBoundingSphere();\n        }\n        if (object.geometry.boundingBox == null) {\n            object.geometry.computeBoundingBox();\n        }\n        for (let i = 0; i < object.count; i++) {\n            object.getMatrixAt(i, matrixHelper);\n            matrixHelper.premultiply(object.matrixWorld);\n            if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper)) {\n                continue;\n            }\n            const intersection = intersectSphereMesh(pointerSphere, object, matrixHelper, i);\n            if (intersection == null) {\n                continue;\n            }\n            target.push(intersection);\n        }\n    }\n    if (!(object instanceof Mesh)) {\n        return;\n    }\n    if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {\n        return;\n    }\n    invertedMatrixHelper.copy(object.matrixWorld).invert();\n    const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);\n    if (intersection == null) {\n        return;\n    }\n    target.push(intersection);\n}\nconst oldInputDevicePointOffset = new Vector3();\nconst inputDeviceQuaternionOffset = new Quaternion();\nconst planeHelper = new Plane();\nconst helperSphere = new Sphere();\nfunction isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {\n    if (geometry.boundingSphere == null) {\n        geometry.computeBoundingSphere();\n    }\n    helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);\n    return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;\n}\nconst vectorHelper = new Vector3();\nconst boxSizeHelper = new Vector3();\nconst boxCenterHelper = new Vector3();\nconst vec0_0001 = new Vector3(0.0001, 0.0001, 0.0001);\nconst invertedMatrixHelper = new Matrix4();\nfunction intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {\n    invertedMatrixHelper.copy(meshMatrixWorld).invert();\n    helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper);\n    const { geometry } = mesh;\n    if (geometry.boundingBox == null) {\n        geometry.computeBoundingBox();\n    }\n    geometry.boundingBox.getSize(boxSizeHelper);\n    geometry.boundingBox.getCenter(boxCenterHelper);\n    geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper);\n    vectorHelper.applyMatrix4(meshMatrixWorld); //world coordinates\n    const distanceToSphereCenterSquared = vectorHelper.distanceToSquared(pointerSphere.center);\n    if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {\n        return undefined;\n    }\n    boxSizeHelper.max(vec0_0001);\n    const normal = helperSphere.center.clone().sub(boxCenterHelper);\n    normal.divide(boxSizeHelper);\n    maximizeAxisVector(normal);\n    const point = vectorHelper.clone();\n    let uv;\n    if (getClosestUV(point2Helper, point, mesh)) {\n        uv = point2Helper.clone();\n    }\n    return {\n        distance: Math.sqrt(distanceToSphereCenterSquared),\n        face: {\n            a: 0,\n            b: 0,\n            c: 0,\n            materialIndex: 0,\n            normal,\n        },\n        uv,\n        normal,\n        point,\n        instanceId,\n        object: mesh,\n    };\n}\nfunction maximizeAxisVector(vec) {\n    const absX = Math.abs(vec.x);\n    const absY = Math.abs(vec.y);\n    const absZ = Math.abs(vec.z);\n    if (absX >= absY && absX >= absZ) {\n        //x biggest\n        vec.set(vec.x < 0 ? -1 : 1, 0, 0);\n        return;\n    }\n    if (absY >= absX && absY >= absZ) {\n        //y biggest\n        vec.set(0, vec.y < 0 ? -1 : 1, 0);\n        return;\n    }\n    //z biggest\n    vec.set(0, 0, vec.z < 0 ? -1 : 1);\n}\n", "import { RayIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createRayPointer(getCamera, space, pointerState, options = {}, pointerType = 'ray') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new RayIntersector(space, options), getCamera, undefined, undefined, undefined, options);\n}\n", "import { LinesIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createLinesPointer(getCamera, space, pointerState, options = {}, pointerType = 'lines') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new LinesIntersector(space, options), getCamera, undefined, undefined, undefined, options);\n}\n", "import { SphereIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createTouchPointer(getCamera, space, pointerState, options = {}, pointerType = 'touch') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.hoverRadius ?? 0.1, options), getCamera, createUpdateTouchPointer(options), undefined, undefined, options);\n}\nfunction createUpdateTouchPointer(options) {\n    let wasPointerDown = false;\n    return (pointer) => {\n        if (!pointer.getEnabled()) {\n            return;\n        }\n        const intersection = pointer.getIntersection();\n        const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? 0.03);\n        if (isPointerDown === wasPointerDown) {\n            return;\n        }\n        const nativeEvent = { timeStamp: performance.now(), button: options.button ?? 0 };\n        if (isPointerDown) {\n            pointer.down(nativeEvent);\n        }\n        else {\n            pointer.up(nativeEvent);\n        }\n        wasPointerDown = isPointerDown;\n    };\n}\nfunction computeIsPointerDown(intersection, downRadius) {\n    if (intersection == null) {\n        return false;\n    }\n    return intersection.distance <= downRadius;\n}\n", "let pointerIdCounter = 23412;\nexport function generateUniquePointerId() {\n    return pointerIdCounter++;\n}\nexport * from './grab.js';\nexport * from './ray.js';\nexport * from './lines.js';\nexport * from './touch.js';\n", "import { generateUniquePointerId } from './index.js';\nimport { SphereIntersector } from '../intersections/sphere.js';\nimport { Pointer } from '../pointer.js';\nexport function createGrabPointer(getCamera, space, pointerState, options = {}, pointerType = 'grab') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.radius ?? 0.07, options), getCamera, undefined, undefined, undefined, options);\n}\n", "import { warn } from '../utils.js';\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n/**\n * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)\n * (universally unique identifier).\n *\n * @return {string} The UUID.\n */\nfunction generateUUID() {\n\n\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\n/**\n * Clamps the given value between min and max.\n *\n * @param {number} value - The value to clamp.\n * @param {number} min - The min value.\n * @param {number} max - The max value.\n * @return {number} The clamped value.\n */\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n/**\n * Computes the Euclidean modulo of the given parameters that\n * is `( ( n % m ) + m ) % m`.\n *\n * @param {number} n - The first parameter.\n * @param {number} m - The second parameter.\n * @return {number} The Euclidean modulo.\n */\nfunction euclideanModulo( n, m ) {\n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n/**\n * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`\n * for the given value.\n *\n * @param {number} x - The value to be mapped.\n * @param {number} a1 - Minimum value for range A.\n * @param {number} a2 - Maximum value for range A.\n * @param {number} b1 - Minimum value for range B.\n * @param {number} b2 - Maximum value for range B.\n * @return {number} The mapped value.\n */\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n/**\n * Returns the percentage in the closed interval `[0, 1]` of the given value\n * between the start and end point.\n *\n * @param {number} x - The start point\n * @param {number} y - The end point.\n * @param {number} value - A value between start and end.\n * @return {number} The interpolation factor.\n */\nfunction inverseLerp( x, y, value ) {\n\n\t// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n/**\n * Returns a value linearly interpolated from two known points based on the given interval -\n * `t = 0` will return `x` and `t = 1` will return `y`.\n *\n * @param {number} x - The start point\n * @param {number} y - The end point.\n * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n * @return {number} The interpolated value.\n */\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n/**\n * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta\n * time to maintain frame rate independent movement. For details, see\n * [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).\n *\n * @param {number} x - The current point.\n * @param {number} y - The target point.\n * @param {number} lambda - A higher lambda value will make the movement more sudden,\n * and a lower value will make the movement more gradual.\n * @param {number} dt - Delta time in seconds.\n * @return {number} The interpolated value.\n */\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n/**\n * Returns a value that alternates between `0` and the given `length` parameter.\n *\n * @param {number} x - The value to pingpong.\n * @param {number} [length=1] - The positive value the function will pingpong to.\n * @return {number} The alternated value.\n */\nfunction pingpong( x, length = 1 ) {\n\n\t// https://www.desmos.com/calculator/vcsjnyz7x4\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n/**\n * Returns a value in the range `[0,1]` that represents the percentage that `x` has\n * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to\n * the `min` and `max`.\n *\n * See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.\n *\n * @param {number} x - The value to evaluate based on its position between min and max.\n * @param {number} min - The min value. Any x value below min will be `0`.\n * @param {number} max - The max value. Any x value above max will be `1`.\n * @return {number} The alternated value.\n */\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\n/**\n * A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)\n * that has zero 1st and 2nd order derivatives at x=0 and x=1.\n *\n * @param {number} x - The value to evaluate based on its position between min and max.\n * @param {number} min - The min value. Any x value below min will be `0`.\n * @param {number} max - The max value. Any x value above max will be `1`.\n * @return {number} The alternated value.\n */\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n/**\n * Returns a random integer from `<low, high>` interval.\n *\n * @param {number} low - The lower value boundary.\n * @param {number} high - The upper value boundary\n * @return {number} A random integer.\n */\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n/**\n * Returns a random float from `<low, high>` interval.\n *\n * @param {number} low - The lower value boundary.\n * @param {number} high - The upper value boundary\n * @return {number} A random float.\n */\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n/**\n * Returns a random integer from `<-range/2, range/2>` interval.\n *\n * @param {number} range - Defines the value range.\n * @return {number} A random float.\n */\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n/**\n * Returns a deterministic pseudo-random float in the interval `[0, 1]`.\n *\n * @param {number} [s] - The integer seed.\n * @return {number} A random float.\n */\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} degrees - A value in degrees.\n * @return {number} The converted value in radians.\n */\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\n/**\n * Converts radians to degrees.\n *\n * @param {number} radians - A value in radians.\n * @return {number} The converted value in degrees.\n */\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\n/**\n * Returns `true` if the given number is a power of two.\n *\n * @param {number} value - The value to check.\n * @return {boolean} Whether the given number is a power of two or not.\n */\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\n/**\n * Returns the smallest power of two that is greater than or equal to the given number.\n *\n * @param {number} value - The value to find a POT for.\n * @return {number} The smallest power of two that is greater than or equal to the given number.\n */\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\n/**\n * Returns the largest power of two that is less than or equal to the given number.\n *\n * @param {number} value - The value to find a POT for.\n * @return {number} The largest power of two that is less than or equal to the given number.\n */\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\n/**\n * Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)\n * defined by the given angles and order.\n *\n * Rotations are applied to the axes in the order specified by order:\n * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.\n *\n * @param {Quaternion} q - The quaternion to set.\n * @param {number} a - The rotation applied to the first axis, in radians.\n * @param {number} b - The rotation applied to the second axis, in radians.\n * @param {number} c - The rotation applied to the third axis, in radians.\n * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.\n */\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarn( 'MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\n/**\n * Denormalizes the given value according to the given typed array.\n *\n * @param {number} value - The value to denormalize.\n * @param {TypedArray} array - The typed array that defines the data type of the value.\n * @return {number} The denormalize (float) value in the range `[0,1]`.\n */\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\n/**\n * Normalizes the given value according to the given typed array.\n *\n * @param {number} value - The float value in the range `[0,1]` to normalize.\n * @param {TypedArray} array - The typed array that defines the data type of the value.\n * @return {number} The normalize value.\n */\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\n/**\n * @class\n * @classdesc A collection of math utility functions.\n * @hideconstructor\n */\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\t/**\n\t * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)\n\t * (universally unique identifier).\n\t *\n\t * @static\n\t * @method\n\t * @return {string} The UUID.\n\t */\n\tgenerateUUID: generateUUID,\n\t/**\n\t * Clamps the given value between min and max.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The value to clamp.\n\t * @param {number} min - The min value.\n\t * @param {number} max - The max value.\n\t * @return {number} The clamped value.\n\t */\n\tclamp: clamp,\n\t/**\n\t * Computes the Euclidean modulo of the given parameters that\n\t * is `( ( n % m ) + m ) % m`.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} n - The first parameter.\n\t * @param {number} m - The second parameter.\n\t * @return {number} The Euclidean modulo.\n\t */\n\teuclideanModulo: euclideanModulo,\n\t/**\n\t * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`\n\t * for the given value.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The value to be mapped.\n\t * @param {number} a1 - Minimum value for range A.\n\t * @param {number} a2 - Maximum value for range A.\n\t * @param {number} b1 - Minimum value for range B.\n\t * @param {number} b2 - Maximum value for range B.\n\t * @return {number} The mapped value.\n\t */\n\tmapLinear: mapLinear,\n\t/**\n\t * Returns the percentage in the closed interval `[0, 1]` of the given value\n\t * between the start and end point.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The start point\n\t * @param {number} y - The end point.\n\t * @param {number} value - A value between start and end.\n\t * @return {number} The interpolation factor.\n\t */\n\tinverseLerp: inverseLerp,\n\t/**\n\t * Returns a value linearly interpolated from two known points based on the given interval -\n\t * `t = 0` will return `x` and `t = 1` will return `y`.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The start point\n\t * @param {number} y - The end point.\n\t * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n\t * @return {number} The interpolated value.\n\t */\n\tlerp: lerp,\n\t/**\n\t * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta\n\t * time to maintain frame rate independent movement. For details, see\n\t * [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The current point.\n\t * @param {number} y - The target point.\n\t * @param {number} lambda - A higher lambda value will make the movement more sudden,\n\t * and a lower value will make the movement more gradual.\n\t * @param {number} dt - Delta time in seconds.\n\t * @return {number} The interpolated value.\n\t */\n\tdamp: damp,\n\t/**\n\t * Returns a value that alternates between `0` and the given `length` parameter.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The value to pingpong.\n\t * @param {number} [length=1] - The positive value the function will pingpong to.\n\t * @return {number} The alternated value.\n\t */\n\tpingpong: pingpong,\n\t/**\n\t * Returns a value in the range `[0,1]` that represents the percentage that `x` has\n\t * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to\n\t * the `min` and `max`.\n\t *\n\t * See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The value to evaluate based on its position between min and max.\n\t * @param {number} min - The min value. Any x value below min will be `0`.\n\t * @param {number} max - The max value. Any x value above max will be `1`.\n\t * @return {number} The alternated value.\n\t */\n\tsmoothstep: smoothstep,\n\t/**\n\t * A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)\n\t * that has zero 1st and 2nd order derivatives at x=0 and x=1.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} x - The value to evaluate based on its position between min and max.\n\t * @param {number} min - The min value. Any x value below min will be `0`.\n\t * @param {number} max - The max value. Any x value above max will be `1`.\n\t * @return {number} The alternated value.\n\t */\n\tsmootherstep: smootherstep,\n\t/**\n\t * Returns a random integer from `<low, high>` interval.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} low - The lower value boundary.\n\t * @param {number} high - The upper value boundary\n\t * @return {number} A random integer.\n\t */\n\trandInt: randInt,\n\t/**\n\t * Returns a random float from `<low, high>` interval.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} low - The lower value boundary.\n\t * @param {number} high - The upper value boundary\n\t * @return {number} A random float.\n\t */\n\trandFloat: randFloat,\n\t/**\n\t * Returns a random integer from `<-range/2, range/2>` interval.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} range - Defines the value range.\n\t * @return {number} A random float.\n\t */\n\trandFloatSpread: randFloatSpread,\n\t/**\n\t * Returns a deterministic pseudo-random float in the interval `[0, 1]`.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} [s] - The integer seed.\n\t * @return {number} A random float.\n\t */\n\tseededRandom: seededRandom,\n\t/**\n\t * Converts degrees to radians.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} degrees - A value in degrees.\n\t * @return {number} The converted value in radians.\n\t */\n\tdegToRad: degToRad,\n\t/**\n\t * Converts radians to degrees.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} radians - A value in radians.\n\t * @return {number} The converted value in degrees.\n\t */\n\tradToDeg: radToDeg,\n\t/**\n\t * Returns `true` if the given number is a power of two.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The value to check.\n\t * @return {boolean} Whether the given number is a power of two or not.\n\t */\n\tisPowerOfTwo: isPowerOfTwo,\n\t/**\n\t * Returns the smallest power of two that is greater than or equal to the given number.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The value to find a POT for.\n\t * @return {number} The smallest power of two that is greater than or equal to the given number.\n\t */\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\t/**\n\t * Returns the largest power of two that is less than or equal to the given number.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The value to find a POT for.\n\t * @return {number} The largest power of two that is less than or equal to the given number.\n\t */\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\t/**\n\t * Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)\n\t * defined by the given angles and order.\n\t *\n\t * Rotations are applied to the axes in the order specified by order:\n\t * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.\n\t *\n\t * @static\n\t * @method\n\t * @param {Quaternion} q - The quaternion to set.\n\t * @param {number} a - The rotation applied to the first axis, in radians.\n\t * @param {number} b - The rotation applied to the second axis, in radians.\n\t * @param {number} c - The rotation applied to the third axis, in radians.\n\t * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.\n\t */\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\t/**\n\t * Normalizes the given value according to the given typed array.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The float value in the range `[0,1]` to normalize.\n\t * @param {TypedArray} array - The typed array that defines the data type of the value.\n\t * @return {number} The normalize value.\n\t */\n\tnormalize: normalize,\n\t/**\n\t * Denormalizes the given value according to the given typed array.\n\t *\n\t * @static\n\t * @method\n\t * @param {number} value - The value to denormalize.\n\t * @param {TypedArray} array - The typed array that defines the data type of the value.\n\t * @return {number} The denormalize (float) value in the range `[0,1]`.\n\t */\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n"],
  "mappings": "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",
  "names": ["length", "start", "end", "invertedMatrixHelper", "scaleHelper", "planeHelper", "point2Helper", "intersection", "length", "scaleHelper", "point2Helper", "planeHelper", "invertedMatrixHelper", "intersection"]
}

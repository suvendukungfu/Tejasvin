{
  "version": 3,
  "sources": ["../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/space.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/gamepad.js", "../../../hidden-heritage-mvp/frontend/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js", "../../../hidden-heritage-mvp/frontend/node_modules/three/examples/jsm/loaders/GLTFLoader.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/hand/pose.js", "../../../hidden-heritage-mvp/frontend/node_modules/three/examples/jsm/utils/SkeletonUtils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/hand/model.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/hand/state.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/hand/visual.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/input.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/visible.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/pointer/cursor.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/pointer/ray.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/pointer/event.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/pointer/default.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/space.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/node_modules/zustand/esm/vanilla.mjs", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/misc.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/init.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/store.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/vanilla/pointer.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/model.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/visual.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/mesh.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/plane.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/utils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/layer.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/teleport.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/hit-test.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/anchor.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller-locomotion.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/index.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/utils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/layout.js", "../../../hidden-heritage-mvp/frontend/node_modules/@pmndrs/xr/dist/controller/state.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/contexts.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/input.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/xr.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/node_modules/zustand/esm/vanilla.mjs", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/node_modules/zustand/esm/index.mjs", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/elements.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/node_modules/zustand/esm/shallow.mjs", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/default.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/controller.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/hand.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/pointer.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/teleport.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/hooks.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/utils.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/mesh.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/plane.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/guard/facing-camera.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/guard/session-mode.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/guard/session-supported.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/guard/focus.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/origin.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/hit-test.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/anchor.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/dom-overlay.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/layer.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/controller-locomotion.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/events.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/deprecated/button.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/deprecated/hooks.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/deprecated/interactive.js", "../../../hidden-heritage-mvp/frontend/node_modules/@react-three/xr/dist/deprecated/ray-grab.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createGetXRSpaceMatrix } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { useXR } from './xr.js';\n/**\n * Component that puts its children in the provided XRSpace (or reference space type)\n *\n * @param props\n * #### `space` - [XRSpaceType](https://developer.mozilla.org/en-US/docs/Web/API/XRSpace) | [XRSpaceType](https://pmndrs.github.io/xr/docs/api/space.XRSpaceType)\n * #### `children` - [ReactNode](https://reactjs.org/docs/introducing-jsx.html#react-jsx)\n * @function\n */\nexport const XRSpace = forwardRef(({ space, children }, ref) => {\n    const internalRef = useRef(null);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const resolvedSpace = typeof space === 'string' ? useXRSpace(space) : space;\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useApplyXRSpaceMatrix(internalRef, resolvedSpace);\n    const setRef = useCallback((group) => {\n        if (group != null) {\n            group.transformReady = false;\n            group.visible = false;\n        }\n        internalRef.current = group;\n    }, []);\n    return (_jsx(\"group\", { xrSpace: resolvedSpace, matrixAutoUpdate: false, ref: setRef, children: resolvedSpace && _jsx(xrSpaceContext.Provider, { value: resolvedSpace, children: children }) }));\n});\nexport function useXRSpace(type) {\n    switch (type) {\n        case 'grip-space':\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            return useXRInputSourceStateContext().inputSource.gripSpace;\n        case 'target-ray-space':\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            return useXRInputSourceStateContext().inputSource.targetRaySpace;\n        case 'wrist':\n        case 'thumb-metacarpal':\n        case 'thumb-phalanx-proximal':\n        case 'thumb-phalanx-distal':\n        case 'thumb-tip':\n        case 'index-finger-metacarpal':\n        case 'index-finger-phalanx-proximal':\n        case 'index-finger-phalanx-intermediate':\n        case 'index-finger-phalanx-distal':\n        case 'index-finger-tip':\n        case 'middle-finger-metacarpal':\n        case 'middle-finger-phalanx-proximal':\n        case 'middle-finger-phalanx-intermediate':\n        case 'middle-finger-phalanx-distal':\n        case 'middle-finger-tip':\n        case 'ring-finger-metacarpal':\n        case 'ring-finger-phalanx-proximal':\n        case 'ring-finger-phalanx-intermediate':\n        case 'ring-finger-phalanx-distal':\n        case 'ring-finger-tip':\n        case 'pinky-finger-metacarpal':\n        case 'pinky-finger-phalanx-proximal':\n        case 'pinky-finger-phalanx-intermediate':\n        case 'pinky-finger-phalanx-distal':\n        case 'pinky-finger-tip':\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            return useXRInputSourceStateContext('hand').inputSource.hand.get(type);\n        case 'root':\n        case 'hips':\n        case 'spine-lower':\n        case 'spine-middle':\n        case 'spine-upper':\n        case 'chest':\n        case 'neck':\n        case 'head':\n        case 'left-shoulder':\n        case 'left-scapula':\n        case 'left-arm-upper':\n        case 'left-arm-lower':\n        case 'left-hand-wrist-twist':\n        case 'right-shoulder':\n        case 'right-scapula':\n        case 'right-arm-upper':\n        case 'right-arm-lower':\n        case 'right-hand-wrist-twist':\n        case 'left-hand-palm':\n        case 'left-hand-wrist':\n        case 'left-hand-thumb-metacarpal':\n        case 'left-hand-thumb-phalanx-proximal':\n        case 'left-hand-thumb-phalanx-distal':\n        case 'left-hand-thumb-tip':\n        case 'left-hand-index-metacarpal':\n        case 'left-hand-index-phalanx-proximal':\n        case 'left-hand-index-phalanx-intermediate':\n        case 'left-hand-index-phalanx-distal':\n        case 'left-hand-index-tip':\n        case 'left-hand-middle-metacarpal':\n        case 'left-hand-middle-phalanx-proximal':\n        case 'left-hand-middle-phalanx-intermediate':\n        case 'left-hand-middle-phalanx-distal':\n        case 'left-hand-middle-tip':\n        case 'left-hand-ring-metacarpal':\n        case 'left-hand-ring-phalanx-proximal':\n        case 'left-hand-ring-phalanx-intermediate':\n        case 'left-hand-ring-phalanx-distal':\n        case 'left-hand-ring-tip':\n        case 'left-hand-little-metacarpal':\n        case 'left-hand-little-phalanx-proximal':\n        case 'left-hand-little-phalanx-intermediate':\n        case 'left-hand-little-phalanx-distal':\n        case 'left-hand-little-tip':\n        case 'right-hand-palm':\n        case 'right-hand-wrist':\n        case 'right-hand-thumb-metacarpal':\n        case 'right-hand-thumb-phalanx-proximal':\n        case 'right-hand-thumb-phalanx-distal':\n        case 'right-hand-thumb-tip':\n        case 'right-hand-index-metacarpal':\n        case 'right-hand-index-phalanx-proximal':\n        case 'right-hand-index-phalanx-intermediate':\n        case 'right-hand-index-phalanx-distal':\n        case 'right-hand-index-tip':\n        case 'right-hand-middle-metacarpal':\n        case 'right-hand-middle-phalanx-proximal':\n        case 'right-hand-middle-phalanx-intermediate':\n        case 'right-hand-middle-phalanx-distal':\n        case 'right-hand-middle-tip':\n        case 'right-hand-ring-metacarpal':\n        case 'right-hand-ring-phalanx-proximal':\n        case 'right-hand-ring-phalanx-intermediate':\n        case 'right-hand-ring-phalanx-distal':\n        case 'right-hand-ring-tip':\n        case 'right-hand-little-metacarpal':\n        case 'right-hand-little-phalanx-proximal':\n        case 'right-hand-little-phalanx-intermediate':\n        case 'right-hand-little-phalanx-distal':\n        case 'right-hand-little-tip':\n        case 'left-upper-leg':\n        case 'left-lower-leg':\n        case 'left-foot-ankle-twist':\n        case 'left-foot-ankle':\n        case 'left-foot-subtalar':\n        case 'left-foot-transverse':\n        case 'left-foot-ball':\n        case 'right-upper-leg':\n        case 'right-lower-leg':\n        case 'right-foot-ankle-twist':\n        case 'right-foot-ankle':\n        case 'right-foot-subtalar':\n        case 'right-foot-transverse':\n        case 'right-foot-ball':\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            return useXR((state) => state.body)?.get(type);\n    }\n    if (type == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const context = useContext(xrSpaceContext);\n        if (context == null) {\n            throw new Error(`XR objects must be placed inside the XROrigin`);\n        }\n        return context;\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const [referenceSpace, setReferenceSpace] = useState(undefined);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const session = useXR((xr) => xr.session);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        let aborted = false;\n        session.requestReferenceSpace(type).then((space) => {\n            if (aborted) {\n                return;\n            }\n            setReferenceSpace(space);\n        });\n        return () => void (aborted = true);\n    }, [session, type]);\n    return referenceSpace;\n}\n/**\n * Hook that returns a function to compute a matrix that contains the transformation of the provided xr space\n */\nexport function useGetXRSpaceMatrix(space) {\n    const localReferenceSpace = useContext(xrSpaceContext);\n    const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);\n    return useMemo(() => (space == null || referenceSpace == null ? undefined : createGetXRSpaceMatrix(space, referenceSpace)), [space, referenceSpace]);\n}\n/**\n * Hook that applies the transformation of the provided xr space to the provided object reference\n *\n * @param onFrame Optional callback that gets executed after the matrix of the reference object was updated\n * @param ref.current A react ref object that points to the object that the XRSpaceMatrix should be applied to\n * @requires matrixAutoUpdate to be disabled for the referenced object\n */\nexport function useApplyXRSpaceMatrix(ref, space, onFrame) {\n    const getXRSpaceMatrix = useGetXRSpaceMatrix(space);\n    useFrame((state, delta, frame) => {\n        if (ref.current != null) {\n            ref.current.visible = ref.current.transformReady = getXRSpaceMatrix?.(ref.current.matrix, frame) ?? false;\n        }\n        onFrame?.(state, delta, frame);\n        //makes sure we update the frame before using the space transformation anywhere\n    }, -100);\n}\n", "import { clamp } from 'three/src/math/MathUtils.js';\nconst ButtonTouchThreshold = 0.05;\nconst AxisTouchThreshold = 0.1;\nexport function updateXRControllerGamepadState(target, inputSource, layout) {\n    const gamepad = inputSource.gamepad;\n    if (gamepad == null) {\n        return;\n    }\n    const layoutComponents = layout.components;\n    for (const key in layoutComponents) {\n        let component = target[key];\n        if (component == null) {\n            target[key] = component = {};\n        }\n        const { gamepadIndices } = layoutComponents[key];\n        let pressed = false;\n        let touched = false;\n        if (gamepadIndices.button != null && gamepadIndices.button < gamepad.buttons.length) {\n            const gamepadButton = gamepad.buttons[gamepadIndices.button];\n            component.button = clamp(gamepadButton.value, 0, 1);\n            pressed ||= gamepadButton.pressed || component.button === 1;\n            touched ||= gamepadButton.touched || component.button > ButtonTouchThreshold;\n        }\n        if (gamepadIndices.xAxis != null && gamepadIndices.xAxis < gamepad.axes.length) {\n            component.xAxis = clamp(gamepad.axes[gamepadIndices.xAxis], -1, 1);\n            touched ||= Math.abs(component.xAxis) > AxisTouchThreshold;\n        }\n        if (gamepadIndices.yAxis != null && gamepadIndices.yAxis < gamepad.axes.length) {\n            component.yAxis = clamp(gamepad.axes[gamepadIndices.yAxis], -1, 1);\n            touched ||= Math.abs(component.yAxis) > AxisTouchThreshold;\n        }\n        component.state = pressed ? 'pressed' : touched ? 'touched' : 'default';\n    }\n}\n", "import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n/**\n * @module BufferGeometryUtils\n * @three_import import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n */\n\n/**\n * Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,\n * and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,\n * because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored\n * UV seams.\n *\n * In comparison to this method, {@link BufferGeometry#computeTangents} (a custom algorithm) generates tangents that\n * probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a\n * custom material, and may be faster than MikkTSpace.\n *\n * Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.\n *\n * @param {BufferGeometry} geometry - The geometry to compute tangents for.\n * @param {Object} MikkTSpace - Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package.\n * Await `MikkTSpace.ready` before use.\n * @param {boolean} [negateSign=true] - Whether to negate the sign component (.w) of each tangent.\n * Required for normal map conventions in some formats, including glTF.\n * @return {BufferGeometry} The updated geometry.\n */\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Merges a set of geometries into a single instance. All geometries must have compatible attributes.\n *\n * @param {Array<BufferGeometry>} geometries - The geometries to merge.\n * @param {boolean} [useGroups=false] - Whether to use groups or not.\n * @return {?BufferGeometry} The merged geometry. Returns `null` if the merge does not succeed.\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * Merges a set of attributes into a single instance. All attributes must have compatible properties and types.\n * Instances of {@link InterleavedBufferAttribute} are not supported.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to merge.\n * @return {?BufferAttribute} The merged attribute. Returns `null` if the merge does not succeed.\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Performs a deep clone of the given buffer attribute.\n *\n * @param {BufferAttribute} attribute - The attribute to clone.\n * @return {BufferAttribute} The cloned attribute.\n */\nfunction deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * Interleaves a set of attributes and returns a new array of corresponding attributes that share a\n * single {@link InterleavedBuffer} instance. All attributes must have compatible types.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to interleave.\n * @return {?Array<InterleavedBufferAttribute>} An array of interleaved attributes. If interleave does not succeed, the method returns `null`.\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * Returns a new, non-interleaved version of the given attribute.\n *\n * @param {InterleavedBufferAttribute} attribute - The interleaved attribute.\n * @return {BufferAttribute} The non-interleaved attribute.\n */\nfunction deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n/**\n * Deinterleaves all attributes on the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to deinterleave.\n */\nfunction deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Returns the amount of bytes used by all attributes to represent the geometry.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The estimate bytes used.\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.\n *\n * @param {BufferGeometry} geometry - The geometry to merge vertices for.\n * @param {number} [tolerance=1e-4] - The tolerance value.\n * @return {BufferGeometry} - The new geometry with merged vertices.\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.\n * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.\n *\n * @param {BufferGeometry} geometry - The geometry to convert.\n * @param {number} drawMode - The current draw mode.\n * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n *\n * Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`\n * will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.\n * Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).\n *\n * @param {Mesh|Line|Points} object - The 3D object to compute morph attributes for.\n * @return {Object} An object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n/**\n * Merges the {@link BufferGeometry#groups} for the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @param {number} [creaseAngle=Math.PI/3] - The crease angle in radians.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tdeepCloneAttribute,\n\tdeinterleaveAttribute,\n\tdeinterleaveGeometry,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace,\n\tInstancedBufferAttribute\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\n/**\n * A loader for the glTF 2.0 format.\n *\n * [glTF](https://www.khronos.org/gltf/} (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/main/specification/2.0)\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)\n * format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver\n * one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,\n * and/or cameras.\n *\n * `GLTFLoader` uses {@link ImageBitmapLoader} whenever possible. Be advised that image bitmaps are not\n * automatically GC-collected when they are no longer referenced, and they require special handling during\n * the disposal process.\n *\n * `GLTFLoader` supports the following glTF 2.0 extensions:\n * - KHR_draco_mesh_compression\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_ior\n * - KHR_materials_specular\n * - KHR_materials_transmission\n * - KHR_materials_iridescence\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_lights_punctual\n * - KHR_texture_basisu\n * - KHR_texture_transform\n * - EXT_texture_webp\n * - EXT_meshopt_compression\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n * - [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)\n * - [MSFT_texture_dds](https://github.com/takahirox/three-gltf-extensions)\n * - [KHR_animation_pointer](https://github.com/needle-tools/three-animation-pointer)\n * - [NEEDLE_progressive](https://github.com/needle-tools/gltf-progressive)\n *\n * ```js\n * const loader = new GLTFLoader();\n *\n * // Optional: Provide a DRACOLoader instance to decode compressed mesh data\n * const dracoLoader = new DRACOLoader();\n * dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );\n * loader.setDRACOLoader( dracoLoader );\n *\n * const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );\n * scene.add( gltf.scene );\n * ```\n *\n * @augments Loader\n * @three_import import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n */\nclass GLTFLoader extends Loader {\n\n\t/**\n\t * Constructs a new glTF loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded glTF asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\t/**\n\t * Sets the given Draco loader to this loader. Required for decoding assets\n\t * compressed with the `KHR_draco_mesh_compression` extension.\n\t *\n\t * @param {DRACOLoader} dracoLoader - The Draco loader to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given KTX2 loader to this loader. Required for loading KTX2\n\t * compressed textures.\n\t *\n\t * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given meshopt decoder. Required for decoding assets\n\t * compressed with the `EXT_meshopt_compression` extension.\n\t *\n\t * @param {Object} meshoptDecoder - The meshopt decoder to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Registers a plugin callback. This API is internally used to implement the various\n\t * glTF extensions but can also used by third-party code to add additional logic\n\t * to the loader.\n\t *\n\t * @param {function(parser:GLTFParser)} callback - The callback function to register.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Unregisters a plugin callback.\n\t *\n\t * @param {Function} callback - The callback function to unregister.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given FBX data and returns the resulting group.\n\t *\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\n\t * @param {string} path - The URL base path.\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\n\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link GLTFLoader#parse}.\n\t *\n\t * @async\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\n\t * @param {string} path - The URL base path.\n\t * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.\n\t */\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n\n\t\tif ( extension.bumpTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n *\n * @private\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n *\n * @private\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n *\n * @private\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n *\n * @private\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\n\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\n\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n *\n * @private\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n *\n * @private\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n *\n * @private\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _quaternion = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_quaternion.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n *\n * @private\n * @param {Object<string, Material>} cache\n * @return {Material}\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n *\n * @private\n * @param {Object3D|Material|BufferGeometry|Object|AnimationClip} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n *\n * @private\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\tif ( uri.search( /\\.ktx2($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/ktx2/ ) === 0 ) return 'image/ktx2';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet safariVersion = - 1;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tconst userAgent = navigator.userAgent;\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;\n\t\t\tconst safariMatch = userAgent.match( /Version\\/(\\d+)/ );\n\t\t\tsafariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;\n\n\t\t\tisFirefox = userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tfor ( const scene of result.scenes ) {\n\n\t\t\t\t\tscene.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t *\n\t * @private\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t *\n\t * @private\n\t * @param {Object} cache\n\t * @param {Object3D} index\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/**\n\t * Returns a reference to a shared resource, cloning it if necessary.\n\t *\n\t * @private\n\t * @param {Object} cache\n\t * @param {number} index\n\t * @param {Object} object\n\t * @return {Object}\n\t */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t *\n\t * @private\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t *\n\t * @private\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t *\n\t * @private\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t *\n\t * @private\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t *\n\t * @private\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\t// Ignore normalized since we copy from sparse\n\t\t\t\tbufferAttribute.normalized = false;\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute.normalized = normalized;\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t *\n\t * @private\n\t * @param {number} textureIndex\n\t * @return {Promise<?Texture>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\t\t\ttexture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( texture, sourceDef );\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t *\n\t * @private\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @param {string} [colorSpace]\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t *\n\t * @private\n\t * @param {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t *\n\t * @private\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * When Object3D instances are targeted by animation, they need unique names.\n\t *\n\t * @private\n\t * @param {string} originalName\n\t * @return {string}\n\t */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @private\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t *\n\t * @private\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t *\n\t * @private\n\t * @param {number} cameraIndex\n\t * @return {Promise<Camera>|undefined}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t *\n\t * @private\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t *\n\t * @private\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst animation = new AnimationClip( animationName, undefined, tracks );\n\n\t\t\tassignExtrasToUserData( animation, animationDef );\n\n\t\t\treturn animation;\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t *\n\t * @private\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t} else if ( nodeDef.mesh !== undefined && parser.meshCache.refs[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\tconst mapping = parser.associations.get( node );\n\t\t\t\tparser.associations.set( node, { ...mapping } );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t *\n\t * @private\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.translation:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\n/**\n * Loader result of `GLTFLoader`.\n *\n * @typedef {Object} GLTFLoader~LoadObject\n * @property {Array<AnimationClip>} animations - An array of animation clips.\n * @property {Object} asset - Meta data about the loaded asset.\n * @property {Array<Camera>} cameras - An array of cameras.\n * @property {GLTFParser} parser - A reference to the internal parser.\n * @property {Group} scene - The default scene.\n * @property {Array<Group>} scenes - glTF assets might define multiple scenes.\n * @property {Object} userData - Additional data.\n **/\n\nexport { GLTFLoader };\n", "import { Matrix4 } from 'three';\nexport function createHandPoseState(hand) {\n    return {\n        //distances: {},\n        //name: undefined,\n        data: new Float32Array(hand.size * 16),\n    };\n}\nexport function updateXRHandPoseState(state, frame, hand, manager, handedness) {\n    const referenceSpace = manager.getReferenceSpace();\n    /*for (const key in poseUrls) {\n      state.distances[key] = Infinity\n    }*/\n    if (referenceSpace == null ||\n        frame == null ||\n        frame.session.visibilityState === 'visible-blurred' ||\n        frame.session.visibilityState === 'hidden') {\n        //state.name = undefined\n        return;\n    }\n    const validPose = updateXRHandPoseData(frame, referenceSpace, hand, state.data);\n    if (!validPose) {\n        //state.name = undefined\n        return;\n    }\n    let closestPoseName;\n    let closestPoseDistance;\n    /*for (const key in poseUrls) {\n      const pose = loadXRHandPose(poseUrls[key])\n      if (pose == null) {\n        continue\n      }\n      const distance = getXRHandPoseDistance(state.data, pose, handedness === 'left')\n  \n      if (closestPoseDistance != null && distance >= closestPoseDistance) {\n        continue\n      }\n  \n      state.distances[key] = distance\n      closestPoseDistance = distance\n      closestPoseName = key\n    }\n  \n    state.name = closestPoseName*/\n}\nconst invertedWirstHelper = new Matrix4();\nconst matrixHelper = new Matrix4();\nfunction updateXRHandPoseData(frame, referenceSpace, hand, handPoseData) {\n    const validPose = frame.fillPoses(hand.values(), referenceSpace, handPoseData);\n    if (!validPose) {\n        return false;\n    }\n    //calculate bone poses in relation to the wrist\n    // The first item in hand pose information is the wrist\n    invertedWirstHelper.fromArray(handPoseData, 0);\n    invertedWirstHelper.invert();\n    for (let i = 0; i < handPoseData.length; i += 16) {\n        matrixHelper.fromArray(handPoseData, i);\n        matrixHelper.premultiply(invertedWirstHelper);\n        matrixHelper.toArray(handPoseData, i);\n    }\n    return true;\n}\n/*\nconst tempMat2 = new Matrix4()\nconst tempMat1 = new Matrix4()\nconst tempQuat2 = new Quaternion()\nconst tempQuat1 = new Quaternion()\n\nfunction getXRHandPoseDistance(hpData1: Float32Array, phData2: Float32Array, mirrorHP2: boolean): number {\n  const length = Math.min(hpData1.length, phData2.length)\n  if (length === 0) {\n    return Infinity\n  }\n  let dist = 0\n  for (let i = 0; i < length; i += 16) {\n\n      //TODO: use decompose\n    tempQuat1.setFromRotationMatrix(tempMat1.fromArray(hpData1, i))\n    tempQuat2.setFromRotationMatrix(tempMat2.fromArray(phData2, i))\n    if (mirrorHP2) {\n      mirrorQuaterionOnXAxis(tempQuat2)\n    }\n    dist += tempQuat2.angleTo(tempQuat1)\n  }\n  return dist / (length * 16)\n}\n\nfunction downloadHandPoseData(handed: XRHandedness, handPoseData: Float32Array) {\n  if (handed === 'left') {\n    const length = handPoseData.length\n    const mirroredHandPoseData = new Float32Array(length)\n    for (let i = 0; i < length; i += 16) {\n      tempMat2.fromArray(handPoseData, i)\n      //TODO: use decompose\n      tempQuat2.setFromRotationMatrix(tempMat2)\n      mirrorQuaterionOnXAxis(tempQuat2)\n      // Copies the rotation component of the supplied matrix m into this matrix rotation component.\n      tempMat2.makeRotationFromQuaternion(tempQuat2)\n      tempMat2.toArray(mirroredHandPoseData, i)\n    }\n    handPoseData = mirroredHandPoseData\n  }\n\n  const a = window.document.createElement('a')\n  a.href = window.URL.createObjectURL(new Blob([handPoseData], { type: 'application/octet-stream' }))\n  a.download = 'untitled.handpose'\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n}\n\n//null means that we are currently loading the pose\nconst poseStorage = new Map<string, Float32Array | undefined | null>()\n\nfunction loadXRHandPose(path: string): Float32Array | undefined {\n  const href = new URL(path, window.location.href).href\n  const pose = poseStorage.get(href)\n  if (pose != null) {\n    return pose\n  }\n  if (pose === undefined) {\n    //loading process was never started\n    poseStorage.set(href, null)\n    //start loading process and save to poseStorage\n    fetch(href)\n      .then((response) => response.arrayBuffer())\n      .then((buffer) => poseStorage.set(href, new Float32Array(buffer)))\n      .catch(console.error)\n  }\n  return undefined\n}\n\nfunction mirrorQuaterionOnXAxis(quaternion: Quaternion): void {\n  quaternion.x = -quaternion.x\n  quaternion.w = -quaternion.w\n}*/\n", "import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * @module SkeletonUtils\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n */\n\nfunction getBoneName( bone, options ) {\n\n\tif ( options.getBoneName !== undefined ) {\n\n\t\treturn options.getBoneName( bone );\n\n\t}\n\n\treturn options.names[ bone.name ];\n\n}\n\n/**\n * Retargets the skeleton from the given source 3D object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n */\nfunction retarget( target, source, options = {} ) {\n\n\tconst quat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveBoneMatrix = false;\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = getBoneName( bone, options );\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tif ( options.localOffsets ) {\n\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\n\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( name === options.hip ) {\n\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\n\n\t\t\tif ( options.hipPosition !== undefined ) {\n\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bone.parent ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\n/**\n * Retargets the animation clip of the source object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {AnimationClip} clip - The animation clip.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n * @return {AnimationClip} The retargeted animation clip.\n */\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\n\t// trim\n\n\tlet start = 0, end = numFrames;\n\n\tif ( options.trim !== undefined ) {\n\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\n\n\t\tmixer.update( options.trim[ 0 ] );\n\n\t} else {\n\n\t\tmixer.update( 0 );\n\n\t}\n\n\tsource.updateMatrixWorld();\n\n\t//\n\n\tfor ( let frame = 0; frame < end; ++ frame ) {\n\n\t\tconst time = frame * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tbone = bones[ j ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( frame === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ frame ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( frame === end - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\n/**\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\n *\n * @param {Object3D} source - The 3D object to clone.\n * @return {Object3D} The cloned 3D object.\n */\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\n/**\n * Retarget options of `SkeletonUtils`.\n *\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\n * @property {number} [fps] - The FPS of the clip.\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\n * @property {string} [hip='hip'] - The name of the source's hip bone.\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\n * @property {number} [scale=1] - The scale.\n **/\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n", "import { Material, Mesh } from 'three';\nimport { clone as cloneSkeleton } from 'three/examples/jsm/utils/SkeletonUtils.js';\nimport { DefaultAssetBasePath, DefaultGltfLoader } from '../index.js';\n//from https://github.com/pmndrs/three-stdlib/blob/main/src/webxr/XRHandMeshModel.ts\nconst DefaultDefaultXRHandProfileId = 'generic-hand';\nexport function getXRHandAssetPath(handedness, options) {\n    const baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n    const defaultProfileId = options?.defaultXRHandProfileId ?? DefaultDefaultXRHandProfileId;\n    return new URL(`${defaultProfileId}/${handedness}.glb`, baseAssetPath).href;\n}\nexport async function loadXRHandModel(assetPath, loader = DefaultGltfLoader) {\n    const gltf = await loader.loadAsync(assetPath);\n    return cloneXRHandGltf(gltf);\n}\nexport function cloneXRHandGltf({ scene }) {\n    const result = cloneSkeleton(scene);\n    const mesh = result.getObjectByProperty('type', 'SkinnedMesh');\n    if (mesh == null) {\n        throw new Error(`missing SkinnedMesh in loaded XRHand model`);\n    }\n    mesh.frustumCulled = false;\n    return result;\n}\nexport function configureXRHandModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { getXRHandAssetPath } from './model.js';\nimport { createHandPoseState, updateXRHandPoseState } from './pose.js';\nexport function isXRHandInputSource(inputSource) {\n    return inputSource.hand != null;\n}\nexport function createXRHandState(id, inputSource, options, events, isPrimary) {\n    return {\n        id,\n        isPrimary,\n        type: 'hand',\n        inputSource: inputSource,\n        pose: createHandPoseState(inputSource.hand),\n        assetPath: getXRHandAssetPath(inputSource.handedness, options),\n        events,\n    };\n}\nexport function updateXRHandState({ inputSource, pose }, frame, manager) {\n    updateXRHandPoseState(pose, frame, inputSource.hand, manager, inputSource.handedness);\n}\n", "const joints = [\n    'wrist',\n    'thumb-metacarpal',\n    'thumb-phalanx-proximal',\n    'thumb-phalanx-distal',\n    'thumb-tip',\n    'index-finger-metacarpal',\n    'index-finger-phalanx-proximal',\n    'index-finger-phalanx-intermediate',\n    'index-finger-phalanx-distal',\n    'index-finger-tip',\n    'middle-finger-metacarpal',\n    'middle-finger-phalanx-proximal',\n    'middle-finger-phalanx-intermediate',\n    'middle-finger-phalanx-distal',\n    'middle-finger-tip',\n    'ring-finger-metacarpal',\n    'ring-finger-phalanx-proximal',\n    'ring-finger-phalanx-intermediate',\n    'ring-finger-phalanx-distal',\n    'ring-finger-tip',\n    'pinky-finger-metacarpal',\n    'pinky-finger-phalanx-proximal',\n    'pinky-finger-phalanx-intermediate',\n    'pinky-finger-phalanx-distal',\n    'pinky-finger-tip',\n];\nexport function createUpdateXRHandVisuals(hand, handModel, referenceSpace) {\n    const buffer = new Float32Array(hand.size * 16);\n    const jointObjects = joints.map((joint) => {\n        const jointObject = handModel.getObjectByName(joint);\n        if (jointObject == null) {\n            throw new Error(`missing joint \"${joint}\" in hand model`);\n        }\n        jointObject.matrixAutoUpdate = false;\n        return jointObject;\n    });\n    return (frame) => {\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (frame == null || resolvedReferenceSpace == null) {\n            return;\n        }\n        frame.fillPoses(hand.values(), resolvedReferenceSpace, buffer);\n        const length = jointObjects.length;\n        for (let i = 0; i < length; i++) {\n            jointObjects[i].matrix.fromArray(buffer, i * 16);\n        }\n    };\n}\n", "import { XRControllerLayoutLoader, createXRControllerState, } from './controller/index.js';\nimport { createXRHandState, } from './hand/index.js';\nexport function isXRInputSourceState(val) {\n    return val != null && typeof val === 'object' && 'inputSource' in val;\n}\nfunction setupEvents(session, events) {\n    const listener = (e) => events.push(e);\n    session.addEventListener('selectstart', listener);\n    session.addEventListener('selectend', listener);\n    session.addEventListener('select', listener);\n    session.addEventListener('squeeze', listener);\n    session.addEventListener('squeezestart', listener);\n    session.addEventListener('squeezeend', listener);\n    return () => {\n        session.removeEventListener('selectstart', listener);\n        session.removeEventListener('selectend', listener);\n        session.removeEventListener('select', listener);\n        session.removeEventListener('squeeze', listener);\n        session.removeEventListener('squeezestart', listener);\n        session.removeEventListener('squeezeend', listener);\n    };\n}\nlet idCounter = 0;\nexport function createSyncXRInputSourceStates(addController, options) {\n    const cleanupMap = new Map();\n    const controllerLayoutLoader = new XRControllerLayoutLoader(options);\n    const idMap = new Map();\n    return (session, current, changes) => {\n        if (changes === 'remove-all') {\n            for (const cleanup of cleanupMap.values()) {\n                cleanup();\n            }\n            return current;\n        }\n        const target = [...current];\n        for (const { added, isPrimary, removed } of changes) {\n            if (removed != null) {\n                for (const inputSource of removed) {\n                    const index = target.findIndex(({ inputSource: is, isPrimary: ip }) => ip === isPrimary && is === inputSource);\n                    if (index === -1) {\n                        continue;\n                    }\n                    target.splice(index, 1);\n                    cleanupMap.get(inputSource)?.();\n                    cleanupMap.delete(inputSource);\n                }\n            }\n            if (added == null) {\n                continue;\n            }\n            for (const inputSource of added) {\n                const events = [];\n                let cleanup = setupEvents(session, events);\n                const key = `${inputSource.handedness}-${inputSource.hand ? 'hand' : 'nohand'}-${inputSource.targetRayMode}-${inputSource.profiles.join(',')}`;\n                let id;\n                if ((id = idMap.get(key)) == null) {\n                    idMap.set(key, (id = `${idCounter++}`));\n                }\n                if (inputSource.hand != null) {\n                    target.push(createXRHandState(id, inputSource, options, events, isPrimary));\n                }\n                else {\n                    switch (inputSource.targetRayMode) {\n                        case 'gaze':\n                            target.push({ id, isPrimary, type: 'gaze', inputSource, events });\n                            break;\n                        case 'screen':\n                            target.push({ id, isPrimary, type: 'screenInput', inputSource, events });\n                            break;\n                        case 'transient-pointer':\n                            target.push({ id, isPrimary, type: 'transientPointer', inputSource, events });\n                            break;\n                        case 'tracked-pointer':\n                            let aborted = false;\n                            const cleanupEvents = cleanup;\n                            cleanup = () => {\n                                cleanupEvents();\n                                aborted = true;\n                            };\n                            const stateResult = createXRControllerState(id, inputSource, controllerLayoutLoader, events, isPrimary);\n                            if (stateResult instanceof Promise) {\n                                stateResult.then((state) => !aborted && addController(state)).catch(console.error);\n                            }\n                            else {\n                                target.push(stateResult);\n                            }\n                            break;\n                    }\n                }\n                cleanupMap.set(inputSource, cleanup);\n            }\n        }\n        return target;\n    };\n}\n", "export function setupSyncIsVisible(store, setIsVisible) {\n    const update = (state, prevState) => {\n        if (prevState != null && state.visibilityState === prevState.visibilityState) {\n            return;\n        }\n        setIsVisible(state.visibilityState === 'visible');\n    };\n    update(store.getState());\n    return store.subscribe(update);\n}\n", "import { MeshBasicMaterial, Quaternion, Vector3, } from 'three';\nexport class PointerCursorMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false, depthWrite: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying vec2 vLocalPosition;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n        vLocalPosition = position.xy * 2.0;`);\n        parameters.fragmentShader = `varying vec2 vLocalPosition;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n          float value = max(0.0, 1.0 - sqrt(dot(vLocalPosition, vLocalPosition)));\n          diffuseColor.a = diffuseColor.a * value * value;`);\n    }\n}\nconst ZAxis = new Vector3(0, 0, 1);\nconst quaternionHelper = new Quaternion();\nconst offsetHelper = new Vector3();\nexport function updatePointerCursorModel(pointerGroup, mesh, material, pointer, options) {\n    const intersection = pointer.getIntersection();\n    if (intersection == null ||\n        !pointer.getEnabled() ||\n        intersection.object.isVoidObject === true ||\n        !isVisble(pointerGroup)) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    mesh.position.copy(intersection.pointOnFace);\n    mesh.scale.setScalar(options.size ?? 0.1);\n    const normal = intersection.normal ?? intersection.face?.normal;\n    if (normal != null) {\n        quaternionHelper.setFromUnitVectors(ZAxis, normal);\n        intersection.object.getWorldQuaternion(mesh.quaternion);\n        mesh.quaternion.multiply(quaternionHelper);\n        offsetHelper.set(0, 0, options.cursorOffset ?? 0.01);\n        offsetHelper.applyQuaternion(mesh.quaternion);\n        mesh.position.add(offsetHelper);\n    }\n    mesh.updateMatrix();\n}\nfunction isVisble({ visible, parent }) {\n    if (!visible) {\n        return false;\n    }\n    if (parent == null) {\n        return true;\n    }\n    return isVisble(parent);\n}\n", "import { MeshBasicMaterial, } from 'three';\nexport class PointerRayMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying float vFade;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n            vFade = position.z + 0.5;`);\n        parameters.fragmentShader = `varying float vFade;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n              diffuseColor.a *= vFade;`);\n    }\n}\nexport function updatePointerRayModel(mesh, material, pointer, options) {\n    const intersection = pointer.getIntersection();\n    if (!pointer.getEnabled() || intersection == null) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    const length = Math.min(options.maxLength ?? 1, intersection.distance);\n    mesh.position.z = -length / 2;\n    const size = options.size ?? 0.005;\n    mesh.scale.set(size, size, length);\n    mesh.updateMatrix();\n}\n", "export function bindXRInputSourceEvent(session, inputSource, event, fn) {\n    const filterFn = (event) => {\n        if (inputSource != 'all' && event.inputSource != inputSource) {\n            return;\n        }\n        fn(event);\n    };\n    session.addEventListener(event, filterFn);\n    return () => session.removeEventListener(event, filterFn);\n}\nexport function bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents, options = {}) {\n    const downListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.down(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const upListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.up(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const downEventName = `${event}start`;\n    const upEventName = `${event}end`;\n    //missing events are required for transient pointers when the input source is registered asynchrounously\n    //so that events directly emitted on initialization are still processed once the input source is created\n    const length = missingEvents.length;\n    for (let i = 0; i < length; i++) {\n        const event = missingEvents[i];\n        switch (event.type) {\n            case downEventName:\n                downListener(event);\n                break;\n            case upEventName:\n                upListener(event);\n                break;\n        }\n    }\n    session.addEventListener(downEventName, downListener);\n    session.addEventListener(upEventName, upListener);\n    return () => {\n        session.removeEventListener(downEventName, downListener);\n        session.removeEventListener(upEventName, upListener);\n    };\n}\n", "export function defaultGrabPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.07, 0, 0.2, 0.4);\n}\nexport function defaultRayPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return 0.4;\n}\nexport function defaultTouchPointerOpacity(pointer) {\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.1, 0.03, 0.2, 0.6);\n}\nfunction map(value, fromMin, fromMax, toMin, toMax) {\n    return toMin + Math.max(0, Math.min(1, (value - fromMin) / (fromMax - fromMin))) * (toMax - toMin);\n}\n", "export function createGetXRSpaceMatrix(space, referenceSpace) {\n    return (target, frame) => {\n        if (space === referenceSpace) {\n            target.identity();\n            return true;\n        }\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (resolvedReferenceSpace == null) {\n            return false;\n        }\n        const pose = frame?.getPose(space, resolvedReferenceSpace);\n        if (pose == null) {\n            return false;\n        }\n        target.fromArray(pose.transform.matrix);\n        return true;\n    };\n}\nexport function getSpaceFromAncestors(object, origin, originReferenceSpace, targetOffsetMatrix) {\n    // Ensure world matrices are up to date for targetObject and all ancestors\n    object.updateWorldMatrix(true, false);\n    targetOffsetMatrix?.copy(object.matrix);\n    const result = getXRSpaceFromAncestorsRec(object.parent, object, targetOffsetMatrix);\n    if (result != null) {\n        return result;\n    }\n    if (targetOffsetMatrix != null) {\n        computeOriginReferenceSpaceOffset(object, origin, targetOffsetMatrix);\n    }\n    return originReferenceSpace;\n}\nfunction computeOriginReferenceSpaceOffset(object, origin, target) {\n    object.updateWorldMatrix(true, false);\n    if (origin == null) {\n        target.copy(object.matrixWorld);\n        return;\n    }\n    origin.updateWorldMatrix(true, false);\n    //origin * offset = space <=>\n    //target = origin.matrixWorld-1 * object.matrixWorld\n    target.copy(origin.matrixWorld).invert().multiply(object.matrixWorld);\n}\n/**\n * Recursively searches ancestors for an xrSpace.\n * @requires The world matrices of object, all its ancestors, and the world matrix of targetObject must be up to date.\n */\nfunction getXRSpaceFromAncestorsRec(object, targetObject, targetOffsetMatrix) {\n    if (object == null) {\n        return undefined;\n    }\n    if (object.xrSpace != null) {\n        // Calculate offset using world matrices instead of accumulating local matrices.\n        // This correctly handles components that override updateWorldMatrix (e.g., UIKit Content).\n        if (targetOffsetMatrix != null) {\n            targetOffsetMatrix.copy(object.matrixWorld).invert().multiply(targetObject.matrixWorld);\n        }\n        return object.xrSpace;\n    }\n    return getXRSpaceFromAncestorsRec(object.parent, targetObject, targetOffsetMatrix);\n}\n", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n", "import { Quaternion, Vector3 } from 'three';\nconst vectorHelper = new Vector3();\nconst directionHelper = new Vector3();\nconst positionHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport function isFacingCamera(camera, object, direction, angle) {\n    //compute object world direction -> directionHelper\n    object.getWorldQuaternion(quaternionHelper);\n    directionHelper.copy(direction).applyQuaternion(quaternionHelper);\n    //compute guardToCamera direction (guard - camera) -> vectorHelper\n    object.getWorldPosition(positionHelper);\n    camera.getWorldPosition(vectorHelper);\n    vectorHelper.sub(positionHelper);\n    //compute the angle between guardToCamera and object world direction\n    return vectorHelper.angleTo(directionHelper) < angle / 2;\n}\nexport function isAppleVisionPro() {\n    return navigator.userAgent.includes('Macintosh') && navigator.xr != null;\n}\n", "import { isAppleVisionPro } from './misc.js';\nexport function buildXRSessionInit(mode, domOverlayRoot, { anchors = true, handTracking = isAppleVisionPro() ? false : true, layers = true, meshDetection = true, planeDetection = true, customSessionInit, depthSensing = false, hitTest = true, domOverlay = true, bodyTracking = false, //until 6.7 since breaking change\nbounded, } = {}) {\n    if (customSessionInit != null) {\n        return customSessionInit;\n    }\n    const requiredFeatures = bounded == null ? ['local-floor'] : bounded ? ['bounded-floor'] : ['unbounded', 'local-floor'];\n    const optionalFeatures = [];\n    if (domOverlay instanceof Element) {\n        domOverlay = true;\n    }\n    addXRSessionFeature(anchors, 'anchors', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(handTracking, 'hand-tracking', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(layers, 'layers', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(meshDetection, 'mesh-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(planeDetection, 'plane-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(depthSensing, 'depth-sensing', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(domOverlay, 'dom-overlay', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(hitTest, 'hit-test', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(bodyTracking, 'body-tracking', requiredFeatures, optionalFeatures);\n    const init = {\n        requiredFeatures,\n        optionalFeatures,\n    };\n    if (domOverlayRoot != null) {\n        init.domOverlay = { root: domOverlayRoot };\n    }\n    //TODO: replace with call to isSupportedFeature (unbounded, ...)\n    if (depthSensing) {\n        Object.assign(init, { depthSensing: { usagePreference: ['gpu-optimized'], dataFormatPreference: [] } });\n    }\n    return init;\n}\nfunction addXRSessionFeature(value, key, requiredFeatures, optionalFeatures) {\n    if (value === false) {\n        return;\n    }\n    if (value === true) {\n        optionalFeatures.push(key);\n        return;\n    }\n    requiredFeatures.push(key);\n}\n", "import { Vector3 } from 'three';\nimport { createStore } from 'zustand/vanilla';\nimport { updateXRControllerState } from './controller/index.js';\nimport { updateXRHandState } from './hand/state.js';\nimport { buildXRSessionInit } from './init.js';\nimport { createSyncXRInputSourceStates } from './input.js';\nexport function resolveInputSourceImplementation(implementation, handedness, defaultValue) {\n    if (typeof implementation === 'function') {\n        return implementation;\n    }\n    if (typeof implementation === 'object') {\n        if (handedness != null && hasKey(implementation, handedness)) {\n            implementation = implementation[handedness];\n        }\n        else if ('default' in implementation) {\n            implementation = implementation.default;\n        }\n    }\n    if (implementation === false) {\n        return false;\n    }\n    if (implementation === true) {\n        return defaultValue;\n    }\n    return implementation ?? defaultValue;\n}\nfunction hasKey(val, key) {\n    return key in val;\n}\nconst baseInitialState = {\n    session: undefined,\n    mediaBinding: undefined,\n    originReferenceSpace: undefined,\n    visibilityState: undefined,\n    mode: null,\n    frameRate: undefined,\n    inputSourceStates: [],\n    detectedMeshes: [],\n    detectedPlanes: [],\n    layerEntries: [],\n};\nasync function injectEmulator(store, emulateOptions, alert) {\n    if (typeof navigator === 'undefined') {\n        return false;\n    }\n    const [vr, ar] = await Promise.all([\n        navigator.xr?.isSessionSupported('immersive-vr').catch((e) => {\n            console.error(e);\n            return false;\n        }),\n        navigator.xr?.isSessionSupported('immersive-ar').catch((e) => {\n            console.error(e);\n            return false;\n        }),\n    ]);\n    if (ar || vr) {\n        return false;\n    }\n    const { emulate } = await import('./emulate.js');\n    if (alert) {\n        window.alert(`emulator started`);\n    }\n    store.setState({\n        emulator: emulate(emulateOptions === true ? 'metaQuest3' : emulateOptions),\n    });\n    return true;\n}\n//helpers for layer sorting\nconst cameraWorldPosition = new Vector3();\nconst tempLayerWorldPosition = new Vector3();\nexport function createXRStore(options) {\n    //dom overlay root element creation\n    const domOverlayRoot = typeof HTMLElement === 'undefined'\n        ? undefined\n        : options?.domOverlay instanceof HTMLElement\n            ? options.domOverlay\n            : document.createElement('div');\n    //store\n    const store = createStore(() => ({\n        ...baseInitialState,\n        controller: options?.controller,\n        hand: options?.hand,\n        gaze: options?.gaze,\n        screenInput: options?.screenInput,\n        transientPointer: options?.transientPointer,\n        domOverlayRoot,\n    }));\n    const unsubscribeSessionOffer = store.subscribe(({ session }, { session: oldSession }) => {\n        if (oldSession != null && session == null && xrManager != null) {\n            offerSession(xrManager, options, domOverlayRoot).catch(console.error);\n        }\n    });\n    //emulation\n    const emulate = options?.emulate ?? 'metaQuest3';\n    let cleanupEmulate;\n    if (typeof window !== 'undefined' && emulate != false) {\n        const inject = (typeof emulate === 'object' ? emulate.inject : undefined) ?? { hostname: 'localhost' };\n        if (inject === true || (typeof inject != 'boolean' && window.location.hostname === inject.hostname)) {\n            injectEmulator(store, emulate, false).then((emulate) => {\n                if (!emulate || xrManager == null) {\n                    return;\n                }\n                offerSession(xrManager, options, domOverlayRoot);\n            });\n        }\n        const keydownListener = (e) => {\n            if (e.altKey && e.metaKey && e.code === 'KeyE') {\n                injectEmulator(store, emulate, true).then((emulate) => {\n                    if (!emulate || xrManager == null) {\n                        return;\n                    }\n                    offerSession(xrManager, options, domOverlayRoot);\n                });\n            }\n        };\n        window.addEventListener('keydown', keydownListener);\n        cleanupEmulate = () => window.removeEventListener('keydown', keydownListener);\n    }\n    //dom overlay root setup\n    let cleanupDomOverlayRoot;\n    if (domOverlayRoot != null) {\n        if (domOverlayRoot.parentNode == null) {\n            const setupDisplay = (state) => {\n                domOverlayRoot.style.display = state.session != null ? 'block' : 'none';\n            };\n            const unsubscribe = store.subscribe(setupDisplay);\n            setupDisplay(store.getState());\n            document.body.appendChild(domOverlayRoot);\n            cleanupDomOverlayRoot = () => {\n                domOverlayRoot.remove();\n                unsubscribe();\n            };\n        }\n        document.body.append(domOverlayRoot);\n    }\n    const syncXRInputSourceStates = createSyncXRInputSourceStates((state) => store.setState({ inputSourceStates: [...store.getState().inputSourceStates, state] }), options);\n    const bindToSession = createBindToSession(store, syncXRInputSourceStates, options?.secondaryInputSources ?? false);\n    const cleanupSessionGrantedListener = setupSessionGrantedListener(options?.enterGrantedSession, (mode) => enterXRSession(domOverlayRoot, mode, options, xrManager));\n    const frameRequests = [];\n    let xrManager;\n    const onSessionStart = () => {\n        store.setState(bindToSession(xrManager.getSession()));\n    };\n    return Object.assign(store, {\n        addLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: [...store.getState().layerEntries, layerEntry] });\n        },\n        removeLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: store.getState().layerEntries.filter((entry) => entry != layerEntry) });\n        },\n        requestFrame() {\n            return new Promise((resolve) => frameRequests.push(resolve));\n        },\n        setWebXRManager(newXrManager) {\n            if (xrManager === newXrManager) {\n                return;\n            }\n            xrManager?.removeEventListener('sessionstart', onSessionStart);\n            xrManager = newXrManager;\n            xrManager.addEventListener('sessionstart', onSessionStart);\n            const { foveation, bounded } = options ?? {};\n            xrManager.setReferenceSpaceType(bounded ? 'bounded-floor' : 'local-floor');\n            if (foveation != null) {\n                xrManager.setFoveation(foveation);\n            }\n            offerSession(xrManager, options, domOverlayRoot).catch(console.error);\n        },\n        setFrameRate(value) {\n            const { session } = store.getState();\n            if (session == null) {\n                return;\n            }\n            setFrameRate(session, value);\n        },\n        setHand(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ hand: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().hand;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                hand: newControllerImplementation,\n            });\n        },\n        setController(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ controller: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().controller;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                controller: newControllerImplementation,\n            });\n        },\n        setTransientPointer(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ transientPointer: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().transientPointer;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                transientPointer: newControllerImplementation,\n            });\n        },\n        setGaze(implementation) {\n            store.setState({ gaze: implementation });\n        },\n        setScreenInput(implementation) {\n            store.setState({ screenInput: implementation });\n        },\n        destroy() {\n            xrManager?.removeEventListener('sessionstart', onSessionStart);\n            cleanupEmulate?.();\n            cleanupDomOverlayRoot?.();\n            cleanupSessionGrantedListener?.();\n            unsubscribeSessionOffer();\n            //unbinding the session\n            bindToSession(undefined);\n        },\n        enterXR: (mode) => enterXRSession(domOverlayRoot, mode, options, xrManager),\n        enterAR: () => enterXRSession(domOverlayRoot, 'immersive-ar', options, xrManager),\n        enterVR: () => enterXRSession(domOverlayRoot, 'immersive-vr', options, xrManager),\n        onBeforeFrame(scene, camera, frame) {\n            let update;\n            const referenceSpace = xrManager?.getReferenceSpace() ?? undefined;\n            const state = store.getState();\n            //update origin\n            const origin = camera.parent ?? scene;\n            if (state.origin != origin) {\n                update ??= {};\n                update.origin = origin;\n            }\n            //update reference space\n            if (referenceSpace != state.originReferenceSpace) {\n                update ??= {};\n                update.originReferenceSpace = referenceSpace;\n            }\n            //set xr space on current origin (and reset on previous)\n            origin.xrSpace = referenceSpace;\n            if (state.origin != origin && state.origin != null) {\n                state.origin.xrSpace = undefined;\n            }\n            if (frame != null) {\n                if (xrManager != null) {\n                    updateSession(store, frame, xrManager);\n                }\n                if (state.body != frame.body) {\n                    update ??= {};\n                    update.body = frame.body;\n                }\n            }\n            if (update != null) {\n                store.setState(update);\n            }\n            if (frame != null) {\n                const length = frameRequests.length;\n                for (let i = 0; i < length; i++) {\n                    frameRequests[i](frame);\n                }\n                frameRequests.length = 0;\n            }\n        },\n        onBeforeRender() {\n            const { session, layerEntries } = store.getState();\n            if (session == null || xrManager == null) {\n                return;\n            }\n            const xrCamera = xrManager.getCamera();\n            //update camera aspect ratio\n            xrCamera.aspect = xrCamera.projectionMatrix.elements[5] / xrCamera.projectionMatrix.elements[0];\n            const currentLayers = session?.renderState.layers;\n            if (currentLayers == null) {\n                return;\n            }\n            //layer sorting\n            xrCamera.getWorldPosition(cameraWorldPosition);\n            layerEntries.sort((entryA, entryB) => {\n                const renderOrderDifference = entryA.renderOrder - entryB.renderOrder;\n                //if renderOrder is the same, sort by distance to camera\n                if (renderOrderDifference !== 0) {\n                    return renderOrderDifference;\n                }\n                entryA.object3D.getWorldPosition(tempLayerWorldPosition);\n                const distA_sq = tempLayerWorldPosition.distanceToSquared(cameraWorldPosition);\n                entryB.object3D.getWorldPosition(tempLayerWorldPosition);\n                const distB_sq = tempLayerWorldPosition.distanceToSquared(cameraWorldPosition);\n                return distB_sq - distA_sq;\n            });\n            let changed = false;\n            const layers = layerEntries.map(({ layer }, i) => {\n                if (layer != currentLayers[i]) {\n                    changed = true;\n                }\n                return layer;\n            });\n            if (!changed) {\n                return;\n            }\n            layers.push(xrManager.getBaseLayer());\n            session.updateRenderState({\n                layers,\n            });\n        },\n    });\n}\nasync function offerSession(manager, options, domOverlayRoot) {\n    //offer session\n    const offerSessionOptions = options?.offerSession ?? true;\n    if (navigator.xr?.offerSession == null || offerSessionOptions === false) {\n        return;\n    }\n    let mode;\n    if (offerSessionOptions === true) {\n        const arSupported = (await navigator.xr.isSessionSupported('immersive-ar')) ?? false;\n        mode = arSupported ? 'immersive-ar' : 'immersive-vr';\n    }\n    else {\n        mode = offerSessionOptions;\n    }\n    const session = await navigator.xr.offerSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));\n    setupXRSession(session, manager, options);\n}\nasync function setFrameRate(session, frameRate) {\n    if (frameRate === false) {\n        return;\n    }\n    const { supportedFrameRates } = session;\n    if (supportedFrameRates == null || supportedFrameRates.length === 0) {\n        return;\n    }\n    if (typeof frameRate === 'function') {\n        const value = frameRate(supportedFrameRates);\n        if (value === false) {\n            return;\n        }\n        await session.updateTargetFrameRate(value);\n        return;\n    }\n    const multiplier = frameRate === 'high' ? 1 : frameRate === 'mid' ? 0.5 : 0;\n    await session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);\n}\nasync function enterXRSession(domOverlayRoot, mode, options, manager) {\n    if (typeof navigator === 'undefined' || navigator.xr == null) {\n        return Promise.reject(new Error(`WebXR not supported`));\n    }\n    if (manager == null) {\n        return Promise.reject(new Error(`not connected to three.js. You either might be missing the <XR> component or the canvas is not yet loaded?`));\n    }\n    const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));\n    await setupXRSession(session, manager, options);\n    return session;\n}\nasync function setupXRSession(session, manager, options) {\n    await Promise.all([setFrameRate(session, options?.frameRate ?? 'high'), setupXRManager(manager, session, options)]);\n}\nasync function setupXRManager(xr, session, options) {\n    if (xr == null) {\n        return;\n    }\n    const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);\n    let frameBufferScaling = options?.frameBufferScaling;\n    if (typeof frameBufferScaling === 'function') {\n        frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);\n    }\n    if (typeof frameBufferScaling === 'string') {\n        frameBufferScaling =\n            frameBufferScaling === 'high' ? maxFrameBufferScalingFactor : frameBufferScaling === 'mid' ? 1 : 0.5;\n    }\n    if (frameBufferScaling != null) {\n        xr?.setFramebufferScaleFactor(frameBufferScaling);\n    }\n    await xr?.setSession(session);\n}\nconst allSessionModes = ['immersive-ar', 'immersive-vr', 'inline'];\nfunction setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR) {\n    if (typeof navigator === 'undefined' || enterGrantedSession === false) {\n        return;\n    }\n    if (enterGrantedSession === true) {\n        enterGrantedSession = allSessionModes;\n    }\n    const sessionGrantedListener = async () => {\n        for (const mode of enterGrantedSession) {\n            if (!(await navigator.xr?.isSessionSupported(mode))) {\n                continue;\n            }\n            enterXR(mode);\n        }\n    };\n    navigator.xr?.addEventListener('sessiongranted', sessionGrantedListener);\n    return () => navigator.xr?.removeEventListener('sessiongranted', sessionGrantedListener);\n}\nfunction createBindToSession(store, syncXRInputSourceStates, secondayInputSources) {\n    let cleanupSession;\n    return (session) => {\n        cleanupSession?.();\n        if (session == null) {\n            return {};\n        }\n        //for debouncing the input source and tracked source changes\n        const inputSourceChangesList = [];\n        let inputSourceChangesTimeout;\n        const applySourcesChange = () => {\n            inputSourceChangesTimeout = undefined;\n            store.setState({\n                inputSourceStates: syncXRInputSourceStates(session, store.getState().inputSourceStates, inputSourceChangesList),\n            });\n            inputSourceChangesList.length = 0;\n        };\n        const onSourcesChange = (isPrimary, e) => {\n            inputSourceChangesList.push({ isPrimary, added: e.added, removed: e.removed });\n            if (inputSourceChangesTimeout != null) {\n                return;\n            }\n            if (secondayInputSources) {\n                inputSourceChangesTimeout = setTimeout(applySourcesChange, 100);\n            }\n            else {\n                applySourcesChange();\n            }\n        };\n        const onInputSourcesChange = onSourcesChange.bind(null, true);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n        let cleanupSecondaryInputSources;\n        if (secondayInputSources) {\n            const onTrackedSourcesChange = onSourcesChange.bind(null, false);\n            session.addEventListener('trackedsourceschange', onTrackedSourcesChange);\n            cleanupSecondaryInputSources = () => session.removeEventListener('trackedsourceschange', onTrackedSourcesChange);\n        }\n        //frameratechange and visibilitychange handlers\n        const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });\n        session.addEventListener('frameratechange', onChange);\n        session.addEventListener('visibilitychange', onChange);\n        //end handler\n        const onEnd = () => {\n            cleanupSession?.();\n            cleanupSession = undefined;\n            store.setState({\n                emulator: store.getState().emulator,\n                ...baseInitialState,\n            });\n        };\n        session.addEventListener('end', onEnd);\n        const initialChanges = [\n            { isPrimary: true, added: session.inputSources },\n        ];\n        if (secondayInputSources) {\n            initialChanges.push({ isPrimary: false, added: session.trackedSources });\n        }\n        const inputSourceStates = syncXRInputSourceStates(session, [], initialChanges);\n        cleanupSession = () => {\n            //cleanup\n            cleanupSecondaryInputSources?.();\n            clearTimeout(inputSourceChangesTimeout);\n            syncXRInputSourceStates(session, store.getState().inputSourceStates, 'remove-all');\n            session.removeEventListener('end', onEnd);\n            session.removeEventListener('frameratechange', onChange);\n            session.removeEventListener('visibilitychange', onChange);\n            session.removeEventListener('inputsourceschange', onInputSourcesChange);\n        };\n        return {\n            inputSourceStates,\n            frameRate: session.frameRate,\n            visibilityState: session.visibilityState,\n            detectedMeshes: [],\n            detectedPlanes: [],\n            mode: session.environmentBlendMode === 'opaque' ? 'immersive-vr' : 'immersive-ar',\n            session,\n            mediaBinding: typeof XRMediaBinding == 'undefined' ? undefined : new XRMediaBinding(session),\n        };\n    };\n}\nfunction updateSession(store, frame, manager) {\n    const referenceSpace = manager.getReferenceSpace();\n    const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, inputSourceStates } = store.getState();\n    if (referenceSpace == null || session == null) {\n        //not in a XR session\n        return;\n    }\n    //update detected planes and meshes\n    const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);\n    const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);\n    if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {\n        store.setState({ detectedPlanes, detectedMeshes });\n    }\n    //update input sources\n    const inputSourceStatesLength = inputSourceStates.length;\n    for (let i = 0; i < inputSourceStatesLength; i++) {\n        const inputSourceState = inputSourceStates[i];\n        switch (inputSourceState.type) {\n            case 'controller':\n                updateXRControllerState(inputSourceState);\n                break;\n            case 'hand':\n                updateXRHandState(inputSourceState, frame, manager);\n                break;\n        }\n    }\n}\nconst emptyArray = [];\nfunction updateDetectedEntities(prevDetectedEntities, detectedEntities) {\n    if (detectedEntities == null) {\n        return emptyArray;\n    }\n    if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {\n        return prevDetectedEntities;\n    }\n    return Array.from(detectedEntities);\n}\nfunction equalContent(set, arr) {\n    if (set.size != arr.length) {\n        return false;\n    }\n    for (const entry of arr) {\n        if (!set.has(entry)) {\n            return false;\n        }\n    }\n    return true;\n}\n", "import { BoxGeometry, Mesh, PlaneGeometry } from 'three';\nimport { onXRFrame } from './utils.js';\nimport { PointerCursorMaterial, updatePointerCursorModel } from '../pointer/cursor.js';\nimport { PointerRayMaterial, updatePointerRayModel } from '../pointer/ray.js';\nconst pointerRayGeometry = new BoxGeometry();\nexport class PointerRayModel extends Mesh {\n    constructor(pointer, options = {}) {\n        const MaterialClass = options.materialClass ?? PointerRayMaterial;\n        const material = new MaterialClass();\n        super(pointerRayGeometry, material);\n        this.renderOrder = options.renderOrder ?? 2;\n        onXRFrame(() => updatePointerRayModel(this, material, pointer, options));\n    }\n}\nconst pointerCursorGeometry = new PlaneGeometry();\nexport class PointerCursorModel extends Mesh {\n    constructor(pointerGroup, pointer, options = {}) {\n        const MaterialClass = options.materialClass ?? PointerCursorMaterial;\n        const material = new MaterialClass();\n        super(pointerCursorGeometry, material);\n        this.renderOrder = options.renderOrder ?? 1;\n        onXRFrame(() => updatePointerCursorModel(pointerGroup, this, material, pointer, options));\n    }\n}\n", "import { Material, Mesh } from 'three';\nimport { DefaultGltfLoader } from '../index.js';\nexport async function loadXRControllerModel(layout, loader = DefaultGltfLoader) {\n    const { scene } = await loader.loadAsync(layout.assetPath);\n    return scene.clone(true);\n}\n/**\n * function for getting the object of a specific component from the xr controller model\n */\nexport function getXRControllerComponentObject(model, layout, componentId) {\n    const component = layout.components[componentId];\n    const firstVisualResponse = component.visualResponses[Object.keys(component.visualResponses)[0]];\n    if (firstVisualResponse == null) {\n        return undefined;\n    }\n    return model.getObjectByName(firstVisualResponse.valueNodeName);\n}\nexport function configureXRControllerModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { Vector2 } from 'three';\nexport function createUpdateXRControllerVisuals(model, layout, gamepadState) {\n    const updateVisuals = [];\n    for (const componentName in layout.components) {\n        const component = layout.components[componentName];\n        let state = gamepadState[componentName];\n        if (state == null) {\n            gamepadState[componentName] = state = {\n                state: 'default',\n            };\n        }\n        updateVisuals.push(...Object.values(component.visualResponses).map((visualResponse) => createUpdateVisualResponse(model, state, visualResponse)));\n    }\n    return () => {\n        const length = updateVisuals.length;\n        for (let i = 0; i < length; i++) {\n            updateVisuals[i]();\n        }\n    };\n}\nfunction createUpdateVisualResponse(model, componentState, visualResponse) {\n    const valueNode = model.getObjectByName(visualResponse.valueNodeName);\n    componentState.object = valueNode;\n    if (valueNode == null) {\n        return () => { };\n    }\n    if (visualResponse.valueNodeProperty === 'visibility') {\n        return () => (valueNode.visible = visualResponse.states.includes(componentState.state));\n    }\n    const minNode = model.getObjectByName(visualResponse.minNodeName);\n    const maxNode = model.getObjectByName(visualResponse.maxNodeName);\n    if (minNode == null || maxNode == null) {\n        return () => { };\n    }\n    return () => {\n        const value = getVisualReponseValue(componentState, visualResponse);\n        valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n        valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n        valueNode.updateMatrix();\n    };\n}\n/**\n * @returns a value between 0 and 1\n */\nfunction getVisualReponseValue(componentState, { componentProperty, states }) {\n    const stateIsActive = states.includes(componentState.state);\n    switch (componentProperty) {\n        case 'xAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).x : 0.5;\n        case 'yAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).y : 0.5;\n        case 'button':\n            return stateIsActive ? (componentState.button ?? 0) : 0;\n        case 'state':\n            return stateIsActive ? 1.0 : 0.0;\n    }\n}\nconst vector2Helper = new Vector2();\n/**\n * project the point (x: [-1, 1], y: [-1, 1]) onto a circle\n */\nfunction getNormalizesAxis({ xAxis = 0, yAxis = 0 }) {\n    const hypotenuse = vector2Helper.lengthSq(); //we can use the length squared since \"1 * 1 = 1\"\n    if (hypotenuse > 1) {\n        const theta = Math.atan2(yAxis, xAxis);\n        vector2Helper.set(Math.cos(theta), Math.sin(theta));\n    }\n    else {\n        //point is inside the circle\n        vector2Helper.set(xAxis, yAxis);\n    }\n    vector2Helper.multiplyScalar(0.5).addScalar(0.5);\n    return vector2Helper;\n}\n", "import { BufferAttribute, BufferGeometry } from 'three';\nexport function updateXRMeshGeometry(mesh, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= mesh.lastChangedTime) {\n        return geometry;\n    }\n    const newGeometry = new BufferGeometry();\n    newGeometry.setIndex(new BufferAttribute(mesh.indices, 1));\n    newGeometry.setAttribute('position', new BufferAttribute(mesh.vertices, 3));\n    return Object.assign(newGeometry, { creationTime: mesh.lastChangedTime });\n}\n", "import { Box2, BufferGeometry, Shape, ShapeGeometry, Vector2 } from 'three';\nexport function updateXRPlaneGeometry(plane, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= plane.lastChangedTime) {\n        return geometry;\n    }\n    return Object.assign(createGeometryFromPolygon(plane.polygon), { createdAt: plane.lastChangedTime });\n}\nconst boxHelper = new Box2();\nconst sizeHelper = new Vector2();\nfunction createGeometryFromPolygon(polygon) {\n    if (polygon.length === 0) {\n        return new BufferGeometry();\n    }\n    const shape = new Shape();\n    const points = polygon.map(({ x, z }) => new Vector2(x, z));\n    //we measure the size and scale & unscale to have normalized UVs for the geometry\n    boxHelper.setFromPoints(points);\n    boxHelper.getSize(sizeHelper);\n    for (const point of points) {\n        point.sub(boxHelper.min);\n        point.divide(sizeHelper);\n    }\n    shape.setFromPoints(points);\n    const geometry = new ShapeGeometry(shape);\n    geometry.scale(sizeHelper.x, sizeHelper.y, 1);\n    geometry.translate(boxHelper.min.x, boxHelper.min.y, 0);\n    geometry.rotateX(Math.PI / 2);\n    return geometry;\n}\n", "/**\n * @param value is allowed to contain nan values\n */\nexport function toDOMPointInit(value, defaultW = 1) {\n    if (value == null) {\n        return undefined;\n    }\n    return {\n        x: nanToDefault(value.x),\n        y: nanToDefault(value.y),\n        z: nanToDefault(value.z),\n        w: 'w' in value ? nanToDefault(value.w, defaultW) : defaultW,\n    };\n}\nexport function nanToDefault(value, defaultValue = 0) {\n    if (isNaN(value)) {\n        return defaultValue;\n    }\n    return value;\n}\n", "import { CylinderGeometry, DepthTexture, HalfFloatType, LinearFilter, Matrix4, PlaneGeometry, Quaternion, SphereGeometry, SRGBColorSpace, Texture, Vector3, VideoTexture, WebGLRenderTarget, } from 'three';\nimport { getSpaceFromAncestors } from './space.js';\nimport { nanToDefault, toDOMPointInit } from './utils.js';\nconst DefaultCentralAngle = (60 / 180) * Math.PI;\nconst DefaultCentralHorizontalAngle = (60 / 180) * Math.PI;\nconst DefaultLowerVerticalAngle = (-30 / 180) * Math.PI;\nconst DefaultUpperVerticalAngle = (30 / 180) * Math.PI;\nexport function createXRLayer(src, state, originReferenceSpace, xrManager, relativeTo, options, properties) {\n    return src instanceof HTMLVideoElement\n        ? createXRVideoLayer(src, state, originReferenceSpace, relativeTo, options, properties)\n        : createXRNormalLayer(src, state.origin, originReferenceSpace, xrManager, relativeTo, options, properties);\n}\nfunction createXRVideoLayer(src, state, originReferenceSpace, relativeTo, { invertStereo, layout, shape = 'quad' }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, state.origin, originReferenceSpace, matrixHelper);\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        invertStereo,\n        layout,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = state.mediaBinding?.[fnName](src, init);\n    if (layer == null) {\n        return undefined;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nfunction createXRNormalLayer(src, origin, originReferenceSpace, xrManager, relativeTo, { shape = 'quad', ...options }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, origin, originReferenceSpace, matrixHelper);\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        ...options,\n        isStatic: !(src instanceof WebGLRenderTarget),\n        textureType: 'texture',\n        viewPixelWidth: options.layout === 'stereo-left-right' ? src.width / 2 : src.width,\n        viewPixelHeight: options.layout === 'stereo-top-bottom' ? src.height / 2 : src.height,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = xrManager.getBinding()?.[fnName](init);\n    if (layer == null) {\n        return undefined;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nconst scaleHelper = new Vector3();\n/**\n * @param matrix is allowed to contain nan values\n */\nfunction matrixToRigidTransform(matrix, scaleTarget = scaleHelper) {\n    //assume matrix can contain nan values\n    matrix.decompose(vectorHelper, quaternionHelper, scaleTarget);\n    scaleTarget.x = nanToDefault(scaleTarget.x);\n    scaleTarget.y = nanToDefault(scaleTarget.y);\n    scaleTarget.z = nanToDefault(scaleTarget.z);\n    return new XRRigidTransform(toDOMPointInit(vectorHelper), toDOMPointInit(quaternionHelper));\n}\nconst segmentPerAngle = 64 / Math.PI;\nfunction computeSegmentAmount(angle) {\n    return Math.ceil(angle * segmentPerAngle);\n}\nexport function setXRLayerRenderTarget(renderer, renderTarget, layerEntry, frame) {\n    if (layerEntry != null && frame != null) {\n        const subImage = renderer.xr.getBinding().getSubImage(layerEntry.layer, frame);\n        renderer.setRenderTargetTextures(renderTarget, subImage.colorTexture);\n    }\n    renderer.setRenderTarget(renderTarget);\n}\nexport function createXRLayerGeometry(shape, properties) {\n    switch (shape) {\n        case 'cylinder':\n            const centralAngle = properties.centralAngle ?? DefaultCentralAngle;\n            return new CylinderGeometry(1, 1, 1, computeSegmentAmount(centralAngle), 1, true, Math.PI - centralAngle / 2, centralAngle).scale(-1, 1, 1);\n        case 'equirect': {\n            const centralHorizontalAngle = properties.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n            const upperVerticalAngle = properties.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n            const lowerVerticalAngle = properties.lowerVerticalAngle ?? DefaultLowerVerticalAngle;\n            const centralVerticalAngle = upperVerticalAngle - lowerVerticalAngle;\n            return new SphereGeometry(1, computeSegmentAmount(centralHorizontalAngle), computeSegmentAmount(centralVerticalAngle), -Math.PI / 2 - centralHorizontalAngle / 2, centralHorizontalAngle, Math.PI / 2 - upperVerticalAngle, centralVerticalAngle).scale(-1, 1, 1);\n        }\n        case 'quad':\n            return new PlaneGeometry();\n    }\n}\nfunction capitalize(text) {\n    return `${text[0].toUpperCase()}${text.slice(1)}`;\n}\nexport function updateXRLayerProperties(target, properties = {}) {\n    target.chromaticAberrationCorrection = properties.chromaticAberrationCorrection;\n    target.quality = properties.quality ?? 'default';\n    target.blendTextureSourceAlpha = properties.blendTextureSourceAlpha ?? false;\n    if (target instanceof XRCylinderLayer) {\n        target.centralAngle = properties?.centralAngle ?? DefaultCentralAngle;\n        return;\n    }\n    if (target instanceof XREquirectLayer) {\n        target.centralHorizontalAngle = properties?.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n        target.lowerVerticalAngle = properties?.lowerVerticalAngle ?? DefaultLowerVerticalAngle;\n        target.upperVerticalAngle = properties?.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n    }\n}\nexport function setupXRImageLayer(renderer, store, layer, src) {\n    let stop = false;\n    const draw = async () => {\n        const frame = await store.requestFrame();\n        if (stop) {\n            return;\n        }\n        writeContentToXRLayer(renderer, layer, frame, src);\n    };\n    layer.addEventListener('redraw', draw);\n    draw();\n    return () => {\n        stop = true;\n        layer.removeEventListener('redraw', draw);\n    };\n}\nexport async function waitForXRLayerSrcSize(src) {\n    if (src instanceof HTMLImageElement && !src.complete) {\n        await new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('load', onResolve);\n            };\n            src.addEventListener('load', onResolve);\n        });\n    }\n    if (src instanceof HTMLVideoElement && src.readyState < 1) {\n        return new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('loadedmetadata', onResolve);\n            };\n            src.addEventListener('loadedmetadata', onResolve);\n        });\n    }\n}\nexport function getXRLayerSrcTexture(src) {\n    if (src instanceof WebGLRenderTarget) {\n        return src.texture;\n    }\n    const texture = src instanceof HTMLVideoElement ? new VideoTexture(src) : new Texture(src);\n    texture.colorSpace = SRGBColorSpace;\n    texture.needsUpdate = true;\n    return texture;\n}\nfunction writeContentToXRLayer(renderer, layer, frame, content) {\n    const context = renderer.getContext();\n    const subImage = renderer.xr.getBinding().getSubImage(layer, frame);\n    renderer.state.bindTexture(context.TEXTURE_2D, subImage.colorTexture);\n    context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);\n    context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, content.width, content.height, context.RGBA, context.UNSIGNED_BYTE, content);\n}\nexport function updateXRLayerTransform(state, target, centralAngle, relativeTo) {\n    if (state.originReferenceSpace == null) {\n        return;\n    }\n    target.space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    target.transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    applyXRLayerScale(getLayerShape(target), target, centralAngle, scaleHelper);\n}\nfunction applyXRLayerScale(shape, target, centralAngle, scale) {\n    if (shape === 'cylinder') {\n        //0.5 * avg of x and z axis\n        const scaleXZ = (scale.x + scale.z) / 2;\n        const radius = scaleXZ;\n        const layerWidth = radius * (centralAngle ?? DefaultCentralAngle);\n        target.radius = radius;\n        target.aspectRatio = scale.y === 0 ? 1 : layerWidth / scale.y;\n    }\n    else if (shape === 'quad') {\n        target.width = scale.x / 2;\n        target.height = scale.y / 2;\n    }\n    else {\n        target.radius = (scale.x + scale.y + scale.z) / 3;\n    }\n}\nexport function getLayerShape(layer) {\n    if (layer instanceof XRCylinderLayer) {\n        return 'cylinder';\n    }\n    if (layer instanceof XREquirectLayer) {\n        return 'equirect';\n    }\n    return 'quad';\n}\nexport function createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr) {\n    return new WebGLRenderTarget(pixelWidth * dpr, pixelHeight * dpr, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        type: HalfFloatType,\n        depthTexture: new DepthTexture(pixelWidth, pixelHeight),\n    });\n}\n", "import { MeshLineGeometry, MeshLineMaterial } from 'meshline';\nimport { Euler, Mesh, QuadraticBezierCurve3, Quaternion, Vector3, } from 'three';\nimport { clamp } from 'three/src/math/MathUtils.js';\n/**\n * marks its children as teleportable\n */\nexport function makeTeleportTarget(root, camera, onTeleport) {\n    root.traverse((object) => (object.userData.teleportTarget = true));\n    const listener = (e) => {\n        if ('point' in e && e.point instanceof Vector3) {\n            const c = typeof camera === 'function' ? camera() : camera;\n            const point = new Vector3().setFromMatrixPosition(c.matrix).negate().setComponent(1, 0).add(e.point);\n            onTeleport(point, e);\n        }\n    };\n    root.addEventListener('pointerup', listener);\n    return () => {\n        root.traverse((object) => (object.userData.teleportTarget = false));\n        root.removeEventListener('pointerup', listener);\n    };\n}\nconst eulerHelper = new Euler(0, 0, 0, 'YXZ');\nconst quaternionHelper = new Quaternion();\n/**\n * @param space\n * @param rayGroup must be placed directly into the scene\n */\nexport function syncTeleportPointerRayGroup(space, rayGroup, deltaTimeMs) {\n    space.updateWorldMatrix(true, false);\n    space.matrixWorld.decompose(rayGroup.position, quaternionHelper, rayGroup.scale);\n    eulerHelper.setFromQuaternion(quaternionHelper);\n    eulerHelper.z = 0;\n    eulerHelper.x = clamp(eulerHelper.x - (10 * Math.PI) / 180, -Math.PI / 2, (1.1 * Math.PI) / 4);\n    quaternionHelper.setFromEuler(eulerHelper);\n    rayGroup.quaternion.slerp(quaternionHelper, deltaTimeMs / 100);\n}\n/**\n * check if the object is marked as teleportable\n */\nexport function isTeleportTarget(object) {\n    return object.userData.teleportTarget === true;\n}\nexport function buildTeleportTargetFilter(options = {}) {\n    return (object, pointerEvents, pointerEventsType, pointerEventsOrder) => {\n        if (!isTeleportTarget(object)) {\n            return false;\n        }\n        if (options.filter != null && !options.filter(object, pointerEvents, pointerEventsType, pointerEventsOrder)) {\n            return false;\n        }\n        return true;\n    };\n}\nexport function createTeleportRayLine() {\n    const curve = new QuadraticBezierCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, -8), new Vector3(0, -20, -15));\n    return curve.getPoints(20);\n}\nexport class TeleportPointerRayModel extends Mesh {\n    multiplier;\n    lineLengths;\n    options = {};\n    constructor(points) {\n        const geometry = new MeshLineGeometry();\n        const float32Array = new Float32Array(points.length * 3);\n        for (let i = 0; i < points.length; i++) {\n            points[i].toArray(float32Array, i * 3);\n        }\n        geometry.setPoints(float32Array);\n        const multiplier = (points.length * 3 - 3) / (points.length * 3 - 1);\n        const material = new MeshLineMaterial({\n            lineWidth: 0.1,\n            resolution: undefined,\n            visibility: multiplier,\n        });\n        super(geometry, material);\n        this.material.transparent = true;\n        this.multiplier = multiplier;\n        this.material = material;\n        this.lineLengths = points.slice(0, -1).map((p, i) => p.distanceTo(points[i + 1]));\n    }\n    update(pointer) {\n        const enabled = pointer.getEnabled();\n        const intersection = pointer.getIntersection();\n        if (!enabled || pointer.getButtonsDown().size === 0 || intersection == null) {\n            this.visible = false;\n            return;\n        }\n        this.visible = true;\n        if (intersection.details.type != 'lines') {\n            this.material.visibility = this.multiplier;\n            return;\n        }\n        const { distanceOnLine, lineIndex } = intersection.details;\n        const lineLength = this.lineLengths[lineIndex];\n        this.material.visibility = (this.multiplier * (lineIndex + distanceOnLine / lineLength)) / this.lineLengths.length;\n        const { color = 'white', opacity = 0.4, size = 0.01 } = this.options;\n        this.material.lineWidth = size;\n        this.material.opacity = typeof opacity === 'function' ? opacity(pointer) : opacity;\n        const resolvedColor = typeof color === 'function' ? color(pointer) : color;\n        if (Array.isArray(resolvedColor)) {\n            this.material.color.set(...resolvedColor);\n        }\n        else {\n            this.material.color.set(resolvedColor);\n        }\n    }\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nimport { getSpaceFromAncestors } from './internals.js';\nimport { toDOMPointInit } from './utils.js';\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst scaleHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport async function createXRHitTestSource(store, session, relativeTo, trackableType = ['point', 'plane', 'mesh']) {\n    if (typeof relativeTo === 'string') {\n        relativeTo = await session.requestReferenceSpace(relativeTo);\n    }\n    const entityTypes = Array.isArray(trackableType) ? trackableType : [trackableType];\n    //necassary data for request and compute hit test results\n    let options;\n    let baseSpace;\n    let object;\n    const state = store.getState();\n    if (relativeTo instanceof XRSpace) {\n        //configure for request and compute hit test results\n        options = { space: relativeTo, entityTypes };\n        object = state.origin;\n    }\n    else {\n        //compute space\n        const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n        if (space == null) {\n            return undefined;\n        }\n        //compute offset ray\n        matrixHelper.decompose(vectorHelper, quaternionHelper, scaleHelper);\n        const point = toDOMPointInit(vectorHelper);\n        vectorHelper.set(0, 0, -1).applyQuaternion(quaternionHelper);\n        const offsetRay = new XRRay(point, toDOMPointInit(vectorHelper, 0));\n        //configure for request and compute hit test results\n        object = relativeTo;\n        options = { space, offsetRay, entityTypes };\n        baseSpace = space;\n    }\n    const source = await session?.requestHitTestSource?.(options);\n    if (source == null) {\n        return undefined;\n    }\n    return {\n        source,\n        getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, store, baseSpace, object),\n    };\n}\nexport async function requestXRHitTest(store, relativeTo, trackableType) {\n    const session = store.getState().session;\n    if (session == null) {\n        return;\n    }\n    const sourceData = await createXRHitTestSource(store, session, relativeTo, trackableType);\n    if (sourceData == null) {\n        return undefined;\n    }\n    const { source, getWorldMatrix } = sourceData;\n    const frame = await store.requestFrame();\n    const results = frame.getHitTestResults?.(source) ?? [];\n    source.cancel();\n    if (results == null) {\n        return undefined;\n    }\n    return { results, getWorldMatrix };\n}\nfunction computeWorldMatrixFromXRHitTestResult(store, baseSpace, object, target, result) {\n    baseSpace ??= store.getState().originReferenceSpace;\n    if (baseSpace == null) {\n        return false;\n    }\n    const pose = result.getPose(baseSpace);\n    if (pose == null) {\n        return false;\n    }\n    //target = ObjectMatrixWorld? * HitTestMatrix\n    target.fromArray(pose.transform.matrix);\n    if (object != null) {\n        object.updateWorldMatrix(true, false);\n        target.premultiply(object.matrixWorld);\n    }\n    return true;\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nimport { toDOMPointInit } from './utils.js';\nconst OneVector = new Vector3(1, 1, 1);\nconst ZeroVector = new Vector3(0, 0, 0);\nconst NeutralQuaternion = new Quaternion();\nconst matrixHelper1 = new Matrix4();\nconst matrixHelper2 = new Matrix4();\nconst quaternionHelper = new Quaternion();\nconst positionHelper = new Vector3();\nconst vectorHelper = new Vector3();\nexport async function requestXRAnchor(store, options) {\n    if (options.relativeTo === 'hit-test-result') {\n        return options.hitTestResult.createAnchor?.(new XRRigidTransform(toDOMPointInit(options.offsetPosition), toDOMPointInit(options.offsetQuaternion)));\n    }\n    let frame;\n    let space;\n    if (options.relativeTo === 'world') {\n        frame = options.frame ?? (await store.requestFrame());\n        const { origin, originReferenceSpace } = store.getState();\n        if (originReferenceSpace == null) {\n            return undefined;\n        }\n        space = originReferenceSpace;\n        const { worldPosition, worldQuaternion } = options;\n        if (origin != null) {\n            //compute vectorHelper and quaternionHelper in the local space of the origin\n            origin.updateWorldMatrix(true, false);\n            matrixHelper1.copy(origin.matrixWorld).invert();\n            matrixHelper2.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);\n            matrixHelper2.decompose(positionHelper, quaternionHelper, vectorHelper);\n        }\n        else {\n            positionHelper.copy(worldPosition);\n            quaternionHelper.copy(worldQuaternion);\n        }\n    }\n    else {\n        frame = options.frame ?? (await store.requestFrame());\n        space = options.space;\n        const { offsetPosition, offsetQuaternion } = options;\n        positionHelper.copy(offsetPosition ?? ZeroVector);\n        quaternionHelper.copy(offsetQuaternion ?? NeutralQuaternion);\n    }\n    return frame.createAnchor?.(new XRRigidTransform(toDOMPointInit(positionHelper), toDOMPointInit(quaternionHelper)), space);\n}\n", "import { Euler, MathUtils, Quaternion, Vector3 } from 'three';\n// useXRControllerLocomotion defaults and constants\nconst defaultSpeed = 2;\nconst defaultSmoothTurningSpeed = 2;\nconst defaultSnapDegrees = 45;\nconst defaultDeadZone = 0.5;\nconst thumbstickPropName = 'xr-standard-thumbstick';\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nconst eulerHelper = new Euler();\nconst positionHelper = new Vector3();\nconst scaleHelper = new Vector3();\n/**\n * Function for handling controller based locomotion in VR\n * @param target Either an `Object`, or a callback function. Recieves translation and rotation input (required).\n * @param translationOptions Options that control the translation of the user. Set to `false` to disable.\n * @param translationOptions.speed The speed at which the user moves.\n * @param rotationOptions Options that control the rotation of the user. Set to `false` to disable.\n * @param rotationOptions.deadZone How far the joystick must be pushed to trigger a turn.\n * @param rotationOptions.type Controls how rotation using the controller functions. Can be either 'smooth' or 'snap'.\n * @param rotationOptions.degrees If `type` is 'snap', this specifies the number of degrees to snap the user's view by.\n * @param rotationOptions.speed If `type` is 'smooth', this specifies the speed at which the user's view rotates.\n * @param translationControllerHand Specifies which hand will control the translation. Can be either 'left' or 'right'.\n */\nexport function createXRControllerLocomotionUpdate() {\n    let canRotate = true;\n    return (target, store, camera, delta, translationOptions = {}, rotationOptions = {}, translationControllerHand = 'left', ...params) => {\n        const { inputSourceStates } = store.getState();\n        const rotationControllerHand = translationControllerHand === 'left' ? 'right' : 'left';\n        const translationController = inputSourceStates.find((state) => isControllerWithHandedness(state, translationControllerHand));\n        const rotationController = inputSourceStates.find((state) => isControllerWithHandedness(state, rotationControllerHand));\n        if (translationController == null || rotationController == null) {\n            return;\n        }\n        const translationThumbstickState = translationController.gamepad[thumbstickPropName];\n        const translationXAxis = translationThumbstickState?.xAxis ?? 0;\n        const translationYAxis = translationThumbstickState?.yAxis ?? 0;\n        const rotationXAxis = rotationController.gamepad[thumbstickPropName]?.xAxis ?? 0;\n        //handle rotation\n        let yRotationChange;\n        if (rotationOptions !== false) {\n            if (rotationOptions === true) {\n                rotationOptions = {};\n            }\n            if (rotationOptions.type === 'smooth') {\n                if (Math.abs(rotationXAxis) > (rotationOptions.deadZone ?? defaultDeadZone)) {\n                    yRotationChange = (rotationXAxis < 0 ? -1 : 1) * delta * (rotationOptions.speed ?? defaultSmoothTurningSpeed);\n                }\n            }\n            else {\n                if (Math.abs(rotationXAxis) < (rotationOptions.deadZone ?? defaultDeadZone)) {\n                    canRotate = true;\n                }\n                else if (canRotate) {\n                    canRotate = false;\n                    yRotationChange =\n                        (rotationXAxis > 0 ? -1 : 1) * MathUtils.degToRad(rotationOptions.degrees ?? defaultSnapDegrees);\n                }\n            }\n        }\n        //handle translation\n        const translationChanged = translationXAxis != 0 || translationYAxis != 0;\n        if (translationOptions !== false && translationChanged) {\n            if (translationOptions === true) {\n                translationOptions = {};\n            }\n            const { speed = defaultSpeed } = translationOptions;\n            vectorHelper.set(translationXAxis * speed, 0, translationYAxis * speed);\n            camera.matrixWorld.decompose(positionHelper, quaternionHelper, scaleHelper);\n            vectorHelper.applyQuaternion(quaternionHelper);\n            if (yRotationChange) {\n                vectorHelper.applyEuler(eulerHelper.set(0, yRotationChange, 0, 'YXZ'));\n            }\n        }\n        if (!translationChanged && yRotationChange == null) {\n            return;\n        }\n        //apply translation and rotation:\n        if (typeof target === 'function') {\n            target(vectorHelper, yRotationChange ?? 0, ...params);\n            return;\n        }\n        if (target == null) {\n            return;\n        }\n        target.position.x += vectorHelper.x * delta;\n        target.position.z += vectorHelper.z * delta;\n        target.rotation.y += yRotationChange ?? 0;\n    };\n}\nfunction isControllerWithHandedness(state, handedness) {\n    return state.type === 'controller' && state.inputSource.handedness === handedness;\n}\n", "import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nexport const DefaultGltfLoader = new GLTFLoader();\nexport const DefaultAssetBasePath = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/';\nexport { getXRControllerComponentObject, configureXRControllerModel, createUpdateXRControllerVisuals, loadXRControllerModel, } from './controller/index.js';\nexport { isXRInputSourceState, } from './input.js';\nexport * from './visible.js';\nexport * from './pointer/index.js';\nexport * from './vanilla/index.js';\nexport * from './misc.js';\nexport * from './teleport.js';\nexport * from './hit-test.js';\nexport * from './anchor.js';\nexport * from './layer.js';\nexport * from './controller-locomotion.js';\n", "export function syncAsync(fn, ...fns) {\n    let value = fn();\n    for (const fnEntry of fns) {\n        if (value instanceof Promise) {\n            value = value.then(fnEntry);\n        }\n        else {\n            value = fnEntry(value);\n        }\n    }\n    return value;\n}\n", "import { DefaultAssetBasePath } from '../index.js';\nimport { syncAsync } from './utils.js';\nconst DefaultDefaultControllerProfileId = 'generic-trigger';\nexport class XRControllerLayoutLoader {\n    baseAssetPath;\n    defaultProfileId;\n    //cache\n    profilesListCache;\n    profileCacheMap = new Map();\n    constructor(options) {\n        this.baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n        this.defaultProfileId = options?.defaultControllerProfileId ?? DefaultDefaultControllerProfileId;\n    }\n    load(inputSourceProfileIds, handedness) {\n        return syncAsync(\n        //load profile\n        () => this.loadProfile(inputSourceProfileIds), \n        //get controller layout from profile\n        (profile) => {\n            for (const key in profile.layouts) {\n                if (!key.includes(handedness)) {\n                    continue;\n                }\n                return profile.layouts[key];\n            }\n            throw new Error(`No matching layout for \"${handedness}\", in profile ${profile.profileId} with layouts ${Object.keys(profile.layouts).join(', ')}.`);\n        });\n    }\n    //alias for Loader compatibility\n    loadAsync = this.load;\n    loadProfile(inputSourceProfileIds) {\n        return syncAsync(\n        //load profiles list\n        () => this.profilesListCache ??\n            fetchJson(new URL('profilesList.json', this.baseAssetPath).href).then((profilesList) => (this.profilesListCache = profilesList)), \n        //load profile\n        (profilesList) => {\n            const length = inputSourceProfileIds.length;\n            let profileInfo;\n            for (let i = 0; i < length; i++) {\n                profileInfo = profilesList[inputSourceProfileIds[i]];\n                if (profileInfo != null) {\n                    break;\n                }\n            }\n            profileInfo ??= profilesList[this.defaultProfileId];\n            if (profileInfo == null) {\n                throw new Error(`no matching profile found for profiles \"${inputSourceProfileIds.join(', ')}\" in profile list ${JSON.stringify(profilesList)}`);\n            }\n            return this.loadProfileFromPath(profileInfo.path);\n        });\n    }\n    loadProfileFromPath(relativeProfilePath) {\n        const result = this.profileCacheMap.get(relativeProfilePath);\n        if (result != null) {\n            return result;\n        }\n        const absoluteProfilePath = new URL(relativeProfilePath, this.baseAssetPath).href;\n        return fetchJson(absoluteProfilePath).then((profile) => {\n            //overwrite the relative assetPath into an absolute path\n            for (const key in profile.layouts) {\n                const layout = profile.layouts[key];\n                if (layout == null) {\n                    continue;\n                }\n                layout.assetPath = new URL(layout.assetPath, absoluteProfilePath).href;\n            }\n            this.profileCacheMap.set(relativeProfilePath, profile);\n            return profile;\n        });\n    }\n}\nasync function fetchJson(url) {\n    let response = await fetch(url);\n    if (!response.ok) {\n        return Promise.reject(new Error(response.statusText));\n    }\n    return response.json();\n}\n", "import { updateXRControllerGamepadState } from './gamepad.js';\nimport { syncAsync } from './utils.js';\nexport function createXRControllerState(id, inputSource, layoutLoader, events, isPrimary) {\n    return syncAsync(() => layoutLoader.load(inputSource.profiles, inputSource.handedness), (layout) => {\n        const gamepad = {};\n        updateXRControllerGamepadState(gamepad, inputSource, layout);\n        return {\n            id,\n            isPrimary,\n            events,\n            type: 'controller',\n            inputSource,\n            gamepad,\n            layout,\n        };\n    });\n}\nexport function updateXRControllerState({ gamepad, inputSource, layout }) {\n    updateXRControllerGamepadState(gamepad, inputSource, layout);\n}\n", "import { createContext } from 'react';\nexport const xrContext = createContext(undefined);\nexport const xrInputSourceStateContext = createContext(undefined);\nexport const xrSpaceContext = createContext(undefined);\nexport const combinedPointerContext = createContext(undefined);\n", "import { bindXRInputSourceEvent, } from '@pmndrs/xr/internals';\nimport { useContext, useEffect } from 'react';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { useXR } from './xr.js';\nexport function useXRInputSourceStates() {\n    return useXR((xr) => xr.inputSourceStates);\n}\nexport function useXRInputSourceState(type, handedness) {\n    return useXR((s) => s.inputSourceStates.find((state) => state.type === type && (handedness == null || state.inputSource.handedness === handedness)));\n}\nexport function useXRInputSourceStateContext(type) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`useXRInputSourceStateContext() can only be used inside the xr store config`);\n    }\n    if (type != null && state.type != type) {\n        throw new Error(`useXRInputSourceStateContext(${type}) can not be used inside a component for input type \"${state.type}\"`);\n    }\n    return state;\n}\n/**\n * Hook for listening to xr input source events\n * @param inputSource The input source to listen to, or 'all' to listen to all input sources\n * @param event The event to listen to. ([List of events](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSourceEvent))\n * @param fn Callback function called when the event is triggered.\n * @param deps Retriggers the binding of the event when the dependencies change.\n */\nexport function useXRInputSourceEvent(inputSource, event, fn, deps) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null || inputSource == null) {\n            return;\n        }\n        return bindXRInputSourceEvent(session, inputSource, event, fn);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [event, inputSource, session, ...deps]);\n}\n", "import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { CombinedPointer } from '@pmndrs/pointer-events';\nimport { setupSyncIsVisible } from '@pmndrs/xr';\nimport { createXRStore as createXRStoreImpl, } from '@pmndrs/xr/internals';\nimport { useFrame, useStore as useRootStore, useThree } from '@react-three/fiber';\nimport { useContext, useEffect, useMemo } from 'react';\nimport { useStore } from 'zustand';\nimport { combinedPointerContext, xrContext } from './contexts.js';\nimport { XRElements } from './elements.js';\n/**\n * Starting point for each XR application.\n * Allows to configure the session's features and defaults such as what controllers are rendered and how they can interact with the scene\n * @returns A new XR store\n */\nexport function createXRStore(options) {\n    return createXRStoreImpl(options);\n}\n/**\n * Core XR component for connecting the `XRStore` with the scene.\n * Requires an `XRStore` which it will provide to its children.\n *\n * @param props\n * #### `children` - Children to be rendered inside the context.\n * #### `store` - The `XRStore` to be used for the session.\n */\nexport function XR({ children, store }) {\n    store.setWebXRManager(useThree((s) => s.gl.xr));\n    const rootStore = useRootStore();\n    useEffect(() => {\n        let initialCamera;\n        return store.subscribe((state, prevState) => {\n            if (state.session === prevState.session) {\n                return;\n            }\n            //session has changed\n            if (state.session != null) {\n                const { camera, gl } = rootStore.getState();\n                initialCamera = camera;\n                rootStore.setState({ camera: gl.xr.getCamera() });\n                return;\n            }\n            if (initialCamera == null) {\n                //we always were in xr?\n                return;\n            }\n            rootStore.setState({ camera: initialCamera });\n        });\n    }, [rootStore, store]);\n    useFrame((state, _delta, frame) => store.onBeforeFrame(state.scene, state.camera, frame), -1000);\n    useFrame(() => store.onBeforeRender());\n    return (_jsx(xrContext.Provider, { value: store, children: _jsxs(RootCombinedPointer, { children: [_jsx(XRElements, {}), children] }) }));\n}\n/**\n * Component for hiding the xr context to all child components. Can be used to create virtual displays and similar allowing the components inside the display to think they are not inside an XR environment, making them behave like when outside XR.\n *\n * @param props\n * @param props.children Children to be rendered inside the context.\n */\nexport function NotInXR({ children }) {\n    const emptyStore = useMemo(() => createXRStore(), []);\n    return _jsx(xrContext.Provider, { value: emptyStore, children: children });\n}\nexport function RootCombinedPointer({ children }) {\n    const store = useXRStore();\n    const pointer = useMemo(() => new CombinedPointer(true), []);\n    useEffect(() => setupSyncIsVisible(store, (visible) => pointer.setEnabled(visible, { timeStamp: performance.now() })), [store, pointer]);\n    useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);\n    return _jsx(combinedPointerContext.Provider, { value: pointer, children: children });\n}\n/**\n * Hook for getting the xr store from the context\n */\nexport function useXRStore() {\n    const store = useContext(xrContext);\n    if (store == null) {\n        throw new Error(`XR features can only be used inside the <XR> component`);\n    }\n    return store;\n}\n/**\n * Returns the XR store object from a parent {@link XR} component. If no component is found `undefined` is returned.\n * You most likely should be using {@link useXRStore} instead.\n */\nexport function UNSAFE_useXRStore() {\n    const store = useContext(xrContext);\n    return store;\n}\n/**\n * Hook for reading the state from the xr store\n */\nexport function useXR(selector = (state) => state, equalityFn) {\n    return useStore(useXRStore(), selector, equalityFn);\n}\n", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n", "import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { resolveInputSourceImplementation } from '@pmndrs/xr/internals';\nimport { context, reconciler, useStore } from '@react-three/fiber';\nimport { Suspense, useMemo } from 'react';\nimport { shallow } from 'zustand/shallow';\nimport { xrInputSourceStateContext, xrSpaceContext } from './contexts.js';\nimport { DefaultXRController, DefaultXRGaze, DefaultXRHand, DefaultXRScreenInput, DefaultXRTransientPointer, } from './default.js';\nimport { useXRSessionVisibilityState } from './hooks.js';\nimport { XRSpace } from './space.js';\nimport { objectToKey } from './utils.js';\nimport { useXR } from './xr.js';\nexport function XRElements({ children }) {\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    const origin = useXR((xr) => xr.origin);\n    const visible = useXRSessionVisibilityState() === 'visible';\n    const store = useStore();\n    const storeWithOriginAsScene = useMemo(() => Object.assign({}, store, {\n        getState() {\n            return { ...store.getState(), scene: origin };\n        },\n    }), [origin, store]);\n    if (origin == null || referenceSpace == null) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: _jsxs(xrSpaceContext.Provider, { value: referenceSpace, children: [_jsxs(\"group\", { matrixAutoUpdate: false, visible: visible, children: [_jsx(XRControllers, {}), _jsx(XRHands, {}), _jsx(XRTransientPointers, {}), _jsx(XRGazes, {}), _jsx(XRScreenInputs, {})] }), children] }) }), storeWithOriginAsScene, null) }));\n}\nfunction XRControllers() {\n    const controllerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'controller'), shallow);\n    let Implementation = useXR((xr) => xr.controller);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: controllerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(XRSpace, { space: \"target-ray-space\", children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRController, { ...ResolvedImpl }) }) }) }, state.id));\n        }) }));\n}\nfunction XRHands() {\n    const handStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'hand'), shallow);\n    const Implementation = useXR((xr) => xr.hand);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: handStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(XRSpace, { space: \"target-ray-space\", children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRHand, { ...ResolvedImpl }) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRTransientPointers() {\n    const transientPointerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'transientPointer'), shallow);\n    const Implementation = useXR((xr) => xr.transientPointer);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: transientPointerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(XRSpace, { space: \"target-ray-space\", children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? (_jsx(ResolvedImpl, {})) : (_jsx(DefaultXRTransientPointer, { ...ResolvedImpl })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRGazes() {\n    const gazeStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'gaze'), shallow);\n    const Implementation = useXR((xr) => xr.gaze);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: gazeStates.map((state) => {\n            return (_jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(XRSpace, { space: \"target-ray-space\", children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRGaze, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRScreenInputs() {\n    const screenInputStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'screenInput'), shallow);\n    const Implementation = useXR((xr) => xr.screenInput);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: screenInputStates.map((state) => {\n            return (_jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(XRSpace, { space: \"target-ray-space\", children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRScreenInput, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "function shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\nexport { shallow as default, shallow$1 as shallow };\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { buildTeleportTargetFilter, createTeleportRayLine, defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, syncTeleportPointerRayGroup, } from '@pmndrs/xr/internals';\nimport { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { Suspense, useContext, useMemo, useRef } from 'react';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { XRControllerModel } from './controller.js';\nimport { XRHandModel } from './hand.js';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { CombinedPointer, PointerCursorModel, PointerRayModel, useGrabPointer, useLinesPointer, usePointerXRInputSourceEvents, useRayPointer, useTouchPointer, } from './pointer.js';\nimport { XRSpace as XRSpaceImpl } from './space.js';\nimport { TeleportPointerRayModel } from './teleport.js';\nexport { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, } from '@pmndrs/xr/internals';\nfunction DefaultXRInputSourceGrabPointer(event, spaceType, options) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const pointer = useGrabPointer(ref, state, options);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);\n    const cursorModelOptions = options.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: spaceType, children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * Grab pointer for the XRHand\n *\n * @param {DefaultXRInputSourceGrabPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `makeDefault` - Used the set the default pointer inside a combined pointer\n * #### `cursorModel` - Properties for configuring how the cursor should look\n * #### `radius` - The size of the intersection sphere\n * #### `customSort` - Overrides the default sort function to use for sorting the intersection results\n */\nexport const DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'select', 'index-finger-tip');\n/**\n * Grab pointer for the XRController\n *\n * @param {DefaultXRInputSourceGrabPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `makeDefault` - Used the set the default pointer inside a combined pointer\n * #### `cursorModel` - Properties for configuring how the cursor should look\n * #### `radius` - The size of the intersection sphere\n * #### `customSort` - Overrides the default sort function to use for sorting the intersection results\n */\nexport const DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'squeeze', 'grip-space');\n/**\n * Ray pointer for the XRInputSource\n *\n * @param {DefaultXRInputSourceRayPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between pointerdown and pointerup to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a dblclick event\n * #### `contextMenuButton` - The button that triggers contextmenu events\n * #### `makeDefault` - Used the set the default pointer inside a combined pointer\n * #### `radius` - The size of the intersection sphere\n * #### `minDistance` - Minimal distance to trigger interactions\n * #### `linePoints` - The points thay make up the shape of the ray if undefined the ray goes in a straight line\n * #### `direction` - The direction of the ray\n * #### `rayModel` - Properties for configuring how the ray should look\n * #### `cursorModel` - Properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceRayPointer(props) {\n    const state = useXRInputSourceStateContext();\n    const ref = useRef(null);\n    const pointer = useRayPointer(ref, state, props);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = props.rayModel;\n    const cursorModelOptions = props.cursorModel;\n    return (_jsxs(XRSpaceImpl, { ref: ref, space: \"target-ray-space\", children: [rayModelOptions !== false && (_jsx(PointerRayModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }));\n}\n/**\n * Touch pointer for the XRHand\n *\n * @param {DefaultXRHandTouchPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `makeDefault` - Used the set the default pointer inside a combined pointer\n * #### `cursorModel` - Properties for configuring how the cursor should look\n * #### `hoverRadius` - The size of the intersection sphere\n * #### `downRadius` - The distance to the touch center to trigger a `pointerdown` event\n * #### `button` - The id of the button that is triggered when touching\n */\nexport function DefaultXRHandTouchPointer(props) {\n    const state = useXRInputSourceStateContext('hand');\n    const ref = useRef(null);\n    const pointer = useTouchPointer(ref, state, props);\n    const cursorModelOptions = props.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.hand.get('index-finger-tip'), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * Default controller implementation with grab and ray pointers\n *\n * @param {DefaultXRControllerOptions} props\n * #### `model` - Options for configuring the controller apperance\n * #### `grabPointer` - Options for configuring the grab pointer\n * #### `rayPointer` - Options for configuring the ray pointer\n * #### `teleportPointer` - Options for configuring the teleport pointer\n */\nexport function DefaultXRController(props) {\n    const modelOptions = props.model;\n    const grabPointerOptions = props.grabPointer;\n    const rayPointerOptions = props.rayPointer;\n    const teleportPointerOptions = props.teleportPointer ?? false;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRControllerModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * Default hand implementation with touch, grab and ray pointers\n *\n * @param {DefaultXRHandOptions} props\n * #### `model` - Options for configuring the hand appearance\n * #### `grabPointer` - Options for configuring the grab pointer\n * #### `rayPointer` - Options for configuring the ray pointer\n * #### `touchPointer` - Options for configuring the touch pointer\n */\nexport function DefaultXRHand(props) {\n    const modelOptions = props.model;\n    const grabPointerOptions = props.grabPointer;\n    const rayPointerOptions = props.rayPointer;\n    const touchPointerOptions = props.touchPointer;\n    const teleportPointerOptions = props.teleportPointer ?? false;\n    const rayPointerRayModelOptions = rayPointerOptions === false ? false : spreadable(rayPointerOptions)?.rayModel;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRHandModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && _jsx(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * Default transient-pointer implementation with ray pointer\n *\n * @param {DefaultXRTransientPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `minDistance` - Minimal distance to trigger interactions\n * #### `linePoints` - The points thay make up the shape of the ray if undefined the ray goes in a straight line\n * #### `direction` - The direction of the ray\n * #### `cursorModel` - Properties for configuring how the cursor should look\n */\nexport function DefaultXRTransientPointer(props) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...props, rayModel: false });\n}\n/**\n * Default gaze implementation with ray pointer\n *\n * @param {DefaultXRGazeOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `minDistance` - Minimal distance to trigger interactions\n * #### `linePoints` - The points thay make up the shape of the ray if undefined the ray goes in a straight line\n * #### `direction` - The direction of the ray\n * #### `cursorModel` - Properties for configuring how the cursor should look\n */\nexport function DefaultXRGaze(props) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...props, rayModel: false });\n}\n/**\n * Default screen-input implementation with ray pointer\n *\n * @param {DefaultXRScreenInputOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `minDistance` - Minimal distance to trigger interactions\n * #### `linePoints` - The points thay make up the shape of the ray if undefined the ray goes in a straight line\n * #### `direction` - The direction of the ray\n */\nexport function DefaultXRScreenInput(props) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...props, cursorModel: false, rayModel: false });\n}\n/**\n * Telport pointer for the XRInputSource.\n * Emits a downward bend ray that only interesects with meshes marked as teleportable\n *\n * @param {DefaultXRInputSourceTeleportPointerOptions} props\n * #### `clickThresholdMs` - Time in milliseconds between `pointerdown` and `pointerup` to trigger a click event\n * #### `dblClickThresholdMs` - Time in milliseconds between the first click and the second click to trigger a `dblclick` event\n * #### `contextMenuButton` - The button that triggers context menu events\n * #### `makeDefault` - Used the set the default pointer inside a combined pointer\n * #### `radius` - The size of the intersection sphere\n * #### `minDistance` - Minimal distance to trigger interactions\n * #### `direction` - The direction of the ray\n * #### `rayModel` - Properties for configuring how the ray should look\n * #### `cursorModel` - Properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceTeleportPointer(props) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const groupRef = useRef(null);\n    const linePoints = useMemo(() => createTeleportRayLine(), []);\n    const pointer = useLinesPointer(groupRef, state, {\n        ...props,\n        linePoints,\n        filter: buildTeleportTargetFilter(props),\n    }, 'teleport');\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = props.rayModel;\n    const cursorModelOptions = props.cursorModel;\n    const scene = useThree((state) => state.scene);\n    const cursorRef = useRef(null);\n    useFrame((_, delta) => {\n        if (cursorRef.current != null) {\n            cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;\n        }\n        const target = groupRef.current;\n        const source = ref.current;\n        if (target == null || source == null) {\n            return;\n        }\n        syncTeleportPointerRayGroup(source, target, delta * 1000);\n    });\n    return (_jsxs(_Fragment, { children: [_jsx(XRSpaceImpl, { ref: ref, space: \"target-ray-space\" }), createPortal(_jsxs(\"group\", { ref: groupRef, children: [rayModelOptions !== false && (_jsx(TeleportPointerRayModel, { linePoints: linePoints, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { ref: cursorRef, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }), scene)] }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { configureXRControllerModel, createUpdateXRControllerVisuals, loadXRControllerModel, XRControllerLayoutLoader, } from '@pmndrs/xr/internals';\nimport { createPortal, useFrame } from '@react-three/fiber';\nimport { forwardRef, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { suspend } from 'suspend-react';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { XRSpace } from './space.js';\n/**\n * Component for placing content in the controller anchored at a specific component such as the Thumbstick\n *\n * @param props\n * #### `id` - `XRControllerGamepadComponentId` Is the id of the component where content should be placed (e.g. `\"a-button\"`)\n * #### `onPress?` - `Function` Is an optional callback to receive when the component is pressed\n * #### `onRelease?` - `Function` Is an optional callback to receive when the component is released\n * #### `children?` - `ReactNode` Children to be placed inside the componenent (e.g. visualizing a tooltip over the button...)\n *\n * @function\n */\nexport const XRControllerComponent = forwardRef(({ id, children, onPress, onRelease }, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const [object, setObject] = useState(undefined);\n    useImperativeHandle(ref, () => object, [object]);\n    useXRControllerButtonEvent(state, id, (state) => (state === 'pressed' ? onPress?.() : onRelease?.()));\n    useFrame(() => setObject(state.gamepad[id]?.object));\n    if (object == null) {\n        return;\n    }\n    return createPortal(children, object);\n});\n/**\n * Hook for subscribing to a button state change event on the controller\n * @param controller the controller to listen for the event\n * @param id of the button\n * @param onChange callback that gets executed when the state of the button changes\n */\nexport function useXRControllerButtonEvent(controller, id, onChange) {\n    const state = useRef(undefined);\n    useFrame(() => {\n        const currentState = controller?.gamepad[id]?.state;\n        if (currentState != null && currentState != state.current) {\n            onChange(currentState);\n        }\n        state.current = currentState;\n    });\n}\nconst LoadXRControllerModelSymbol = Symbol('loadXRControllerModel');\n/**\n * Component for rendering a 3D model for the XRController\n * @param props\n * #### `colorWrite` - Configures the colorWrite property of the model\n * #### `renderOrder` - Configures the render order model\n * @function\n */\nexport const XRControllerModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const model = suspend(loadXRControllerModel, [state.layout, undefined, LoadXRControllerModelSymbol]);\n    configureXRControllerModel(model, options);\n    state.object = model;\n    useImperativeHandle(ref, () => model, [model]);\n    const update = useMemo(() => createUpdateXRControllerVisuals(model, state.layout, state.gamepad), [model, state.layout, state.gamepad]);\n    useFrame(update);\n    return (_jsx(XRSpace, { space: \"grip-space\", children: _jsx(\"primitive\", { object: model }) }));\n});\nconst LoadXRControllerLayoutSymbol = Symbol('loadXRControllerLayout');\n/**\n * For rendering a controller that is not included in WebXR. (e.g controller tutorials/demos)\n *\n * @param profileIds\n * @param handedness\n * @param XRControllerLayoutLoaderOptions\n * @returns Promise<XRControllerLayout>\n */\nexport function useLoadXRControllerLayout(profileIds, handedness, { baseAssetPath, defaultControllerProfileId } = {}) {\n    const loader = useMemo(() => new XRControllerLayoutLoader({ baseAssetPath, defaultControllerProfileId }), [baseAssetPath, defaultControllerProfileId]);\n    return suspend(() => {\n        const result = loader.loadAsync(profileIds, handedness);\n        return result instanceof Promise ? result : Promise.resolve(result);\n    }, [LoadXRControllerLayoutSymbol, handedness, ...profileIds]);\n}\n/**\n * Loads the controller model for the given layout. This is a suspendable function, so it can be used with React Suspense.\n * @param layout: XRControllerLayout\n * @returns Promise<THREE.Group>\n */\nexport function useLoadXRControllerModel(layout) {\n    return suspend(loadXRControllerModel, [layout, undefined, LoadXRControllerModelSymbol]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { cloneXRHandGltf, configureXRHandModel, createUpdateXRHandVisuals, } from '@pmndrs/xr/internals';\nimport { useFrame, useLoader } from '@react-three/fiber';\nimport { forwardRef, useImperativeHandle, useMemo } from 'react';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { XRSpace, useXRSpace } from './space.js';\n/**\n * Component for rendering a 3D model for the XRHand\n *\n * @param props\n * #### `colorWrite` - Configures color writing\n * #### `renderOrder` - Configures the render order of the model\n * @function\n */\nexport const XRHandModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('hand');\n    const gltf = useLoader(GLTFLoader, state.assetPath);\n    const model = useMemo(() => cloneXRHandGltf(gltf), [gltf]);\n    configureXRHandModel(model, options);\n    state.object = model;\n    useImperativeHandle(ref, () => model, [model]);\n    const referenceSpace = useXRSpace();\n    const update = useMemo(() => createUpdateXRHandVisuals(state.inputSource.hand, model, referenceSpace), [state.inputSource, model, referenceSpace]);\n    useFrame((_state, _delta, frame) => update(frame));\n    return _jsx(\"primitive\", { object: model });\n});\n/**\n * Component for placing content in the hand anchored at a specific joint such as the index finger tip.\n *\n * @param props\n * #### `joint` - [XRHandJoint](https://developer.mozilla.org/en-US/docs/Web/API/XRHand#hand_joints) Is the name of the joint where content should be placed (e.g. `\"wrist\"`)\n * #### `children` - Components to be placed inside the joint (e.g. For visualizing a tooltip over the index finger tip)\n *\n * @function\n * @deprecated use `<XRSpace space=\"wrist\">` instead of `<XRHandJoint joint=\"wrist\">`\n */\nexport const XRHandJoint = forwardRef(({ joint, children }, ref) => {\n    return (_jsx(XRSpace, { ref: ref, space: joint, children: children }));\n});\n", "import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { CombinedPointer as CombinedPointerImpl, Pointer, createGrabPointer, createLinesPointer, createRayPointer, createTouchPointer, } from '@pmndrs/pointer-events';\nimport { PointerCursorMaterial, PointerRayMaterial, bindPointerXRInputSourceEvent, updatePointerCursorModel, updatePointerRayModel, } from '@pmndrs/xr/internals';\nimport { createPortal, useFrame, useStore, useThree } from '@react-three/fiber';\nimport { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport { combinedPointerContext } from './contexts.js';\nimport { useXR } from './xr.js';\n//for checking if `event.pointerState` is from an xr input source\nexport { isXRInputSourceState } from '@pmndrs/xr/internals';\n/**\n * Component for combining multiple Pointers into one so that only one pointer is active at a time\n *\n * @param props\n * @param props.children? - `Pointer` components to combine\n */\nexport function CombinedPointer({ children }) {\n    const pointer = useMemo(() => new CombinedPointerImpl(false), []);\n    useSetupPointer(pointer);\n    return _jsx(combinedPointerContext.Provider, { value: pointer, children: children });\n}\nfunction clearObject(object) {\n    for (const key of Object.keys(object)) {\n        delete object[key];\n    }\n}\n/**\n * Hook for creating a grab pointer\n */\nexport function useGrabPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const store = useStore();\n    const pointer = useMemo(() => createGrabPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * Hook for creating a ray pointer\n */\nexport function useRayPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const store = useStore();\n    const pointer = useMemo(() => createRayPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * Hook for creating a ray pointer\n */\nexport function useLinesPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const store = useStore();\n    const pointer = useMemo(() => createLinesPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * Hook for creating a touch pointer\n */\nexport function useTouchPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const store = useStore();\n    const pointer = useMemo(() => createTouchPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * Component for rendering a ray for a pointer\n * @param props\n * #### `materialClass` - Material to use for the ray\n * #### `pointer` - Pointer to use for the ray\n * #### `renderOrder` - Render order for the ray\n * @function\n */\nexport const PointerRayModel = forwardRef((props, ref) => {\n    const material = useMemo(() => {\n        const MaterialClass = props.materialClass ?? PointerRayMaterial;\n        return new MaterialClass();\n    }, [props.materialClass]);\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null && updatePointerRayModel(internalRef.current, material, props.pointer, props));\n    return (_jsx(\"mesh\", { matrixAutoUpdate: false, renderOrder: props.renderOrder ?? 2, ref: internalRef, material: material, children: _jsx(\"boxGeometry\", {}) }));\n});\n/**\n * Component for rendering a cursor as a pointer\n *\n * @param props\n * #### `materialClass` - Class of the material to use for the cursor\n * #### `pointer` - Pointer to use for the cursor\n * #### `renderOrder` - Render order for the cursor\n * @function\n */\nexport const PointerCursorModel = forwardRef((props, ref) => {\n    const material = useMemo(() => {\n        const MaterialClass = props.materialClass ?? PointerCursorMaterial;\n        return new MaterialClass();\n    }, [props.materialClass]);\n    const internalRef = useRef(null);\n    const groupRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null &&\n        groupRef.current != null &&\n        updatePointerCursorModel(groupRef.current, internalRef.current, material, props.pointer, props));\n    const scene = useThree((s) => s.scene);\n    return (_jsxs(_Fragment, { children: [_jsx(\"group\", { ref: groupRef }), createPortal(_jsx(\"mesh\", { renderOrder: props.renderOrder ?? 1, ref: internalRef, matrixAutoUpdate: false, material: material, children: _jsx(\"planeGeometry\", {}) }), scene)] }));\n});\n/**\n * Hook for binding the xr session events such as `selectstart` to the provided pointer down/up events\n */\nexport function usePointerXRInputSourceEvents(pointer, inputSource, event, missingEvents) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        return bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents);\n    }, [event, inputSource, pointer, session, missingEvents]);\n}\nfunction useSetupPointer(pointer, makeDefault = false) {\n    const combinedPointer = useContext(combinedPointerContext);\n    if (combinedPointer == null) {\n        throw new Error(`xr pointers can only be used inside the XR component`);\n    }\n    useEffect(() => {\n        const unregister = combinedPointer.register(pointer, makeDefault);\n        return () => {\n            unregister();\n        };\n    }, [combinedPointer, pointer, makeDefault]);\n    useEffect(() => {\n        if (!(pointer instanceof Pointer)) {\n            return;\n        }\n        return () => pointer.exit({ timeStamp: performance.now() });\n    }, [pointer]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { makeTeleportTarget, TeleportPointerRayModel as TeleportPointerRayModelImpl, } from '@pmndrs/xr';\nimport { useFrame, useStore } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\n/**\n * Component that allows to declare its children as teleport targets.\n * @param props\n * @param props.onTeleport Function that is called when the teleport target is hit\n */\nexport function TeleportTarget({ children, onTeleport, }) {\n    const ref = useRef(null);\n    const teleportRef = useRef(onTeleport);\n    teleportRef.current = onTeleport;\n    const store = useStore();\n    useEffect(() => {\n        if (ref.current == null) {\n            return;\n        }\n        return makeTeleportTarget(ref.current, () => store.getState().camera, (point, event) => teleportRef.current?.(point, event));\n    }, [store]);\n    return (_jsx(\"group\", { pointerEventsType: { allow: 'teleport' }, ref: ref, children: children }));\n}\nexport const TeleportPointerRayModel = forwardRef(({ pointer, linePoints, ...options }, ref) => {\n    const mesh = useMemo(() => new TeleportPointerRayModelImpl(linePoints), [linePoints]);\n    useImperativeHandle(ref, () => mesh, [mesh]);\n    mesh.options = options;\n    useFrame(() => mesh.update(pointer));\n    return _jsx(\"primitive\", { object: mesh });\n});\n", "import { useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\nimport { useXR } from './xr.js';\nexport function useHover(ref, onChange) {\n    let setHover;\n    let hover;\n    if (onChange == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const [_hover, _setHover] = useState(false);\n        setHover = _setHover;\n        hover = _hover;\n    }\n    else {\n        setHover = onChange;\n    }\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const set = new Set();\n        const enter = (e) => {\n            if (set.size === 0) {\n                setHover(true, e);\n            }\n            set.add(e.pointerId);\n        };\n        const leave = (e) => {\n            set.delete(e.pointerId);\n            if (set.size === 0) {\n                setHover(false, e);\n            }\n        };\n        current.addEventListener('pointerenter', enter);\n        current.addEventListener('pointerleave', leave);\n        return () => {\n            current.removeEventListener('pointerenter', enter);\n            current.removeEventListener('pointerleave', leave);\n        };\n    }, [ref, setHover]);\n    return hover;\n}\n/**\n * Gets the visibility state of the XR session.\n *\n * @returns The visibility state of the XR session.\n */\nexport function useXRSessionVisibilityState() {\n    return useXR((xr) => xr.visibilityState);\n}\n/**\n * Initilizes the room capture process.\n *\n * @returns A function to initiate room capture, or undefined if unavailable.\n */\nexport function useInitRoomCapture() {\n    return useXR((xr) => xr.session?.initiateRoomCapture?.bind(xr.session));\n}\n/**\n * Checks whether a specific XRSessionMode is supported or not\n *\n * @param {XRSessionMode} mode - The `XRSessionMode` to check against.\n * @param {(error: any) => void} [onError] - Callback executed when an error occurs.\n */\nexport function useXRSessionModeSupported(mode, onError) {\n    const onErrorRef = useRef(onError);\n    onErrorRef.current = onError;\n    const [subscribe, getSnapshot] = useMemo(() => {\n        let sessionSupported = undefined;\n        return [\n            (onChange) => {\n                let canceled = false;\n                if (typeof navigator === 'undefined' || navigator.xr == null) {\n                    sessionSupported = false;\n                    return () => { };\n                }\n                navigator.xr\n                    .isSessionSupported(mode)\n                    .then((isSupported) => {\n                    sessionSupported = isSupported;\n                    if (canceled) {\n                        return;\n                    }\n                    onChange();\n                })\n                    .catch((e) => {\n                    if (canceled) {\n                        return;\n                    }\n                    onErrorRef.current?.(e);\n                });\n                return () => (canceled = true);\n            },\n            () => sessionSupported,\n        ];\n    }, [mode]);\n    return useSyncExternalStore(subscribe, getSnapshot);\n}\n/**\n * @deprecated use `useXRSessionModeSupported` instead\n */\nexport const useSessionModeSupported = useXRSessionModeSupported;\n/**\n * Checks if a specific XR session feature is enabled.\n *\n * @param {string} feature - The XR session feature to check against.\n * @returns {boolean} Whether the feature is enabled.\n */\nexport function useXRSessionFeatureEnabled(feature) {\n    return useXR(({ session }) => session?.enabledFeatures?.includes(feature) ?? false);\n}\n/**\n * @deprecated use `useXRSessionFeatureEnabled` instead\n */\nexport const useSessionFeatureEnabled = useXRSessionFeatureEnabled;\n", "let i = 0;\nconst map = new Map();\nexport function objectToKey(object) {\n    let key = map.get(object);\n    if (key == null) {\n        map.set(object, (key = i++));\n    }\n    return key;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { updateXRMeshGeometry } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useXR } from './xr.js';\n/**\n * Component for rendering a mesh for the XRMesh based on the detected mesh geometry\n *\n * @param props\n * Accepts the same props as a ThreeJs [Mesh](https://threejs.org/docs/#api/en/objects/Mesh)\n * @function\n */\nexport const XRMeshModel = forwardRef(({ mesh, ...rest }, ref) => {\n    const geometry = useXRMeshGeometry(mesh);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * Hook for getting all detected meshes with the provided semantic label\n */\nexport function useXRMeshes(semanticLabel) {\n    const meshes = useXR((xr) => xr.detectedMeshes);\n    return useMemo(() => (semanticLabel == null ? meshes : meshes.filter((mesh) => mesh.semanticLabel === semanticLabel)), [meshes, semanticLabel]);\n}\n/**\n * Hook for getting the geometry from the detected mesh\n *\n * @param mesh the detected mesh\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRMeshGeometry(mesh, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRMeshGeometry(mesh, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRMeshGeometry(mesh, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { updateXRPlaneGeometry } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useXR } from './xr.js';\n/**\n * Component for rendering a mesh for the XRPlane based on the detected plane geometry\n *\n * @param props\n * Accepts the same props as a ThreeJs [Mesh](https://threejs.org/docs/#api/en/objects/Mesh)\n * @function\n */\nexport const XRPlaneModel = forwardRef(({ plane, ...rest }, ref) => {\n    const geometry = useXRPlaneGeometry(plane);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * Hook for getting all dected planes with the provided semantic label\n */\nexport function useXRPlanes(semanticLabel) {\n    const planes = useXR((xr) => xr.detectedPlanes);\n    return useMemo(() => (semanticLabel == null ? planes : planes.filter((plane) => plane.semanticLabel === semanticLabel)), [planes, semanticLabel]);\n}\n/**\n * Hook for getting the geometry from the detected plane\n *\n * @param plane the detected plane\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRPlaneGeometry(plane, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRPlaneGeometry(plane, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRPlaneGeometry(plane, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { isFacingCamera } from '@pmndrs/xr';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { useRef, useState } from 'react';\nfunction useIsFacingCamera(ref, set, direction, angle) {\n    const camera = useThree((state) => state.camera);\n    useFrame(() => {\n        if (ref.current == null) {\n            return;\n        }\n        set(isFacingCamera(camera, ref.current, direction, angle));\n    });\n}\n/**\n * Guard that only **shows** its children by toggling their visibility if the camera is facing the object.\n * Calculation is based on the provided angle and direction.\n *\n * @param props\n * #### `children` - `ReactNode` The ReactNode elements to conditionally show.\n * #### `direction` - [Vector3](https://threejs.org/docs/#api/en/math/Vector3) Direction vector to check against the camera's facing direction.\n * #### `angle` - `number` The angle in radians to determine visibility. Defaults to `Math.PI / 2` (90 degrees).\n */\nexport function ShowIfFacingCamera({ children, direction, angle = Math.PI / 2 }) {\n    const ref = useRef(null);\n    useIsFacingCamera(ref, (visible) => {\n        if (ref.current == null) {\n            return;\n        }\n        ref.current.visible = visible;\n    }, direction, angle);\n    return _jsx(\"group\", { ref: ref, children: children });\n}\n/**\n * Guard that only **renders** its children into the scene if the camera is facing the object.\n * Calculation is based on the provided angle and direction.\n *\n * @param props\n * #### `children` - `ReactNode` The ReactNode elements to conditionally render.\n * #### `direction` - [Vector3](https://threejs.org/docs/#api/en/math/Vector3) Direction vector to check against the camera's facing direction.\n * #### `angle` - `number` The angle in radians to determine visibility. Defaults to `Math.PI / 2` (90 degrees).\n */\nexport function IfFacingCamera({ children, direction, angle = Math.PI / 2 }) {\n    const ref = useRef(null);\n    const [show, setShow] = useState(false);\n    useIsFacingCamera(ref, setShow, direction, angle);\n    return _jsx(\"group\", { ref: ref, children: show ? children : null });\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXR } from '../index.js';\nfunction useIsInSessionMode(allow, deny) {\n    const mode = useXR((state) => state.mode);\n    if (deny != null) {\n        return Array.isArray(deny) ? !deny.includes(mode) : deny != mode;\n    }\n    if (allow != null) {\n        return Array.isArray(allow) ? allow.includes(mode) : allow === mode;\n    }\n    return mode !== null;\n}\n/**\n * Guard that only **shows** its children by toggling their visibility based on the current session mode.\n * If neither `allow` nor `deny` are provided, the visiblity will be based on whether or not any mode is currently being used.\n *\n * @param props\n * #### `children?` - `ReactNode` The ReactNode elements to conditionally show.\n * #### `allow?` - `XRSessionMode | ReadonlyArray<XRSessionMode | undefined>` The session mode(s) where the children will be shown. If not provided, the children will be shown in all modes except the ones in `deny`.\n * #### `deny?` - `XRSessionMode | ReadonlyArray<XRSessionMode | undefined>` The session mode(s) where the children will be hidden.\n */\nexport function ShowIfInSessionMode({ children, allow, deny }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return _jsx(\"group\", { visible: visible, children: children });\n}\n/**\n * Guard that only **renders** its children to the scene based on the current session mode.\n * If neither `allow` nor `deny` are provided, the elements will be rendered based on whether or not any mode is currently being used.\n *\n * @param props\n * #### `children?` - `ReactNode` The ReactNode elements to conditionally render.\n * #### `allow?` - `XRSessionMode | ReadonlyArray<XRSessionMode | undefined>` The session mode(s) where the children will be rendered. If not provided, the children will be rendered in all modes except the ones in `deny`.\n * #### `deny?` - `XRSessionMode | ReadonlyArray<XRSessionMode | undefined>` The session mode(s) where the children will not be rendered.\n */\nexport function IfInSessionMode({ children, allow, deny }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return visible ? _jsx(_Fragment, { children: children }) : null;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXRSessionModeSupported } from '../index.js';\n/**\n * Guard that only **shows** its children by toggling their visibility based on whether the user's device supports a session mode.\n *\n * @param props\n * #### `children?` - `ReactNode` The ReactNode elements to conditionally show.\n * #### `mode` - `XRSessionMode` The session mode used to determine if the children will be shown.\n */\nexport function ShowIfSessionModeSupported({ children, mode }) {\n    const supported = useXRSessionModeSupported(mode);\n    return _jsx(\"group\", { visible: supported, children: children });\n}\n/**\n * Guard that only **renders** its children to the scene based on whether the user's device supports a session mode.\n *\n * @param props\n * #### `children?` - `ReactNode` The ReactNode elements to conditionally render.\n * #### `mode` - `XRSessionMode` The session mode used to determine if the children will be rendered.\n */\nexport function IfSessionModeSupported({ children, mode }) {\n    const supported = useXRSessionModeSupported(mode);\n    if (!supported) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXRSessionVisibilityState } from '../index.js';\n/**\n * Guard that only **shows** its children by toggling their visibility based on whether the current session is visible or not.\n * Typically used to hide/show content when operating system overlays are showing\n *\n * @param props \n * #### `children?` - `ReactNode` The ReactNode elements to conditionally show.\n */\nexport function ShowIfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    return _jsx(\"group\", { visible: state == null || state === 'visible', children: children });\n}\n/**\n * Guard that only **renders** its children to the scene based on whether the current session is visible or not.\n * Typically used to hide/show content when operating system overlays are showing\n *\n * @param props \n * #### `children?` - `ReactNode` The ReactNode elements to conditionally show.\n */\nexport function IfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    if (state != 'visible' && state != null) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useThree } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useRef } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\n/**\n * Component for setting the origin of the player (their feet)\n *\n * @param props\n * Accepts the same props as a ThreeJs [Group](https://threejs.org/docs/#api/en/objects/Group)\n * @function\n */\nexport const XROrigin = forwardRef(({ children, disabled, ...props }, ref) => {\n    const xrCamera = useThree((s) => s.gl.xr.getCamera());\n    const internalRef = useRef(null);\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useEffect(() => {\n        const group = internalRef.current;\n        if (group == null || disabled) {\n            return;\n        }\n        group.add(xrCamera);\n        return () => void group.remove(xrCamera);\n    }, [disabled, xrCamera]);\n    return (_jsx(\"group\", { ref: internalRef, ...props, children: _jsx(xrSpaceContext.Provider, { value: referenceSpace, children: children }) }));\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { useStore } from 'zustand';\nimport { useXRStore } from './xr.js';\nexport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\n/**\n * Hook for creating a hit test source originating from the provided object or XRSpace. The provided object must be statically positioned in the XRSpace.\n *\n * @param relativeTo - The XRSpace, XRReferenceSpace, or Object3D to perform hit-tests from\n * @param trackableType - A string, or array of strings that specify the types of surfaces to hit test against ('point', 'plane', 'mesh')\n *\n * @example\n * function ManualHitTest() {\n *   const meshRef = useRef<Mesh>(null)\n *   const hitTestSource = useXRHitTestSource('viewer')\n *   const [someCondition, setSomeCondition] = useState(false)\n *   const [hitResults, setHitResults] = useState<XRHitTestResult[]>([])\n *\n *   useFrame((_, __, frame: XRFrame | undefined) => {\n *     // Only perform hit testing when certain conditions are met\n *     if (frame && hitTestSource && someCondition) {\n *       const results = frame.getHitTestResults(hitTestSource.source)\n *       setHitResults(results)\n *     }\n *   })\n *   return (\n *     <IfInSessionMode allow={'immersive-ar'}>\n *       <XRDomOverlay>\n *         <button onClick={() => setSomeCondition(true)}>Turn on hit testing</button>\n *       </XRDomOverlay>\n *     </IfInSessionMode>\n *   )\n * }\n *\n * @see [Hit Test Tutorial](https://pmndrs.github.io/xr/docs/tutorials/hit-test)\n * @see [Hit Test Example](https://pmndrs.github.io/xr/examples/hit-testing/)\n */\nexport function useXRHitTestSource(relativeTo, trackableType) {\n    const [source, setState] = useState();\n    useCreateXRHitTestSource(relativeTo, trackableType, setState);\n    return source;\n}\n/**\n * Hook for setting up a continous hit test originating from the provided object or XRSpace. The provided object must be statically positioned in the XRSpace.\n *\n * @param fn - Callback function that contains the results of the hit test, and a function to retrieve the world matrix\n * @param relativeTo - The XRSpace, XRReferenceSpace, or Object3D to perform hit-tests from\n * @param trackableType - A string, or array of strings that specify the types of surfaces to hit test against ('point', 'plane', 'mesh')\n *\n * @example\n * const matrixHelper = new Matrix4()\n * const hitTestPosition = new Vector3()\n *\n * function ContinuousHitTest() {\n *   const previewRef = useRef<Mesh>(null)\n *\n *   useXRHitTest(\n *     (results, getWorldMatrix) => {\n *       if (results.length === 0) return\n *\n *       getWorldMatrix(matrixHelper, results[0])\n *       hitTestPosition.setFromMatrixPosition(matrixHelper)\n *     },\n *     'viewer'\n *   )\n *\n *   useFrame(() => {\n *     if (hitTestPosition && previewRef.current) {\n *       previewRef.current.position.copy(hitTestPosition)\n *     }\n *   })\n *\n *   return (\n *       <mesh ref={previewRef} position={hitPosition}>\n *         <sphereGeometry args={[0.05]} />\n *         <meshBasicMaterial color=\"red\" />\n *       </mesh>\n *   )\n * }\n *\n * @see [Hit Test Tutorial](https://pmndrs.github.io/xr/docs/tutorials/hit-test)\n * @see [Hit Test Example](https://pmndrs.github.io/xr/examples/hit-testing/)\n */\nexport function useXRHitTest(fn, relativeTo, trackableType) {\n    const sourceRef = useRef(undefined);\n    useCreateXRHitTestSource(relativeTo, trackableType, useCallback((source) => (sourceRef.current = source), []));\n    useFrame((_s, _d, frame) => {\n        if (fn == null || frame == null || sourceRef.current == null) {\n            return;\n        }\n        fn(frame.getHitTestResults(sourceRef.current.source), sourceRef.current.getWorldMatrix);\n    });\n}\nfunction useCreateXRHitTestSource(relativeTo, trackableType, onLoad) {\n    const store = useXRStore();\n    const session = useStore(store, (s) => s.session);\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        let storedResult;\n        let cancelled = false;\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo?.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        createXRHitTestSource(store, session, relativeToResolved, trackableType).then((result) => {\n            if (cancelled) {\n                return;\n            }\n            storedResult = result;\n            onLoad(result);\n        });\n        return () => {\n            onLoad(undefined);\n            cancelled = true;\n            storedResult?.source.cancel();\n        };\n    }, [session, store, relativeTo, trackableType, onLoad]);\n}\n/**\n * Hook that returns a function to request a single hit test. Cannot be called in the useFrame hook.\n *\n * @example\n * const matrixHelper = new Matrix4()\n * function EventDrivenHitTest() {\n *   const requestHitTest = useXRRequestHitTest()\n *   const [placedObjects, setPlacedObjects] = useState<Vector3[]>([])\n *\n *   const handleTap = async () => {\n *     const hitTestResult = await requestHitTest('viewer', ['plane', 'mesh'])\n *     const { results, getWorldMatrix } = hitTestResult\n *     if (results?.length > 0) {\n *       getWorldMatrix(matrixHelper, results[0])\n *       const position = new Vector3().setFromMatrixPosition(matrixHelper)\n *       setPlacedObjects((prev) => [...prev, position])\n *     }\n *   }\n *\n *   return (\n *     <>\n *       <IfInSessionMode allow={'immersive-ar'}>\n *         <XRDomOverlay>\n *           <button onClick={handleTap}>Place Object</button>\n *         </XRDomOverlay>\n *       </IfInSessionMode>\n *\n *       {placedObjects.map((position, index) => (\n *         <mesh key={index} position={position}>\n *           <sphereGeometry args={[0.1]} />\n *           <meshBasicMaterial color=\"blue\" />\n *         </mesh>\n *       ))}\n *     </>\n *   )\n * }\n *\n * @see [Hit Test Tutorial](https://pmndrs.github.io/xr/docs/tutorials/hit-test)\n * @see [Hit Test Example](https://pmndrs.github.io/xr/examples/hit-testing/)\n */\nexport function useXRRequestHitTest() {\n    const store = useXRStore();\n    return useCallback((relativeTo, trackableType) => {\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        return requestXRHitTest(store, relativeToResolved, trackableType);\n    }, [store]);\n}\n/**\n * A convenience wrapper component for the useXRHitTest hook. Used to setup hit testing in the scene.\n *\n * @param props\n * #### `space` - [XRSpaceType](https://developer.mozilla.org/en-US/docs/Web/API/XRSpace) | [XRReferenceSpaceType](https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types)\n * #### `onResults` - Callback function that is called with the results of the hit test\n *\n * @example\n * const matrixHelper = new Matrix4()\n * const hitTestPosition = new Vector3()\n *\n * const store = createXRStore({\n *   hand: () => {\n *     const inputSourceState = useXRInputSourceStateContext()\n *\n *     return (\n *       <>\n *         <DefaultXRHand />\n *         <XRHitTest\n *           space={inputSourceState.inputSource.targetRaySpace}\n *           onResults={(results, getWorldMatrix) => {\n *             if (results.length === 0) return\n *             getWorldMatrix(matrixHelper, results[0])\n *             hitTestPosition.setFromMatrixPosition(matrixHelper)\n *           }}\n *         />\n *       </>\n *     )\n *   },\n * })\n *\n * @see [Hit Test Tutorial](https://pmndrs.github.io/xr/docs/tutorials/hit-test)\n * @see [Hit Test Example](https://pmndrs.github.io/xr/examples/hit-testing/)\n * @function\n */\nexport const XRHitTest = forwardRef(({ trackableType, onResults, space, ...rest }, ref) => {\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current);\n    useXRHitTest(onResults, space ?? internalRef, trackableType);\n    return _jsx(\"group\", { ...rest, ref: internalRef });\n});\n", "import { requestXRAnchor } from '@pmndrs/xr';\nimport { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { useXRStore } from './xr.js';\nexport { requestXRAnchor,\n//requestXRPersistentAnchor,\n//loadXRPersistentAnchor,\n//deleteXRPersistentAnchor,\n } from '@pmndrs/xr';\n/**\n * Hook that returns a function that allows to request a xr anchor\n */\nexport function useRequestXRAnchor() {\n    const store = useXRStore();\n    return useMemo(() => requestXRAnchor.bind(null, store), [store]);\n}\n/**\n * hook that returns a function that allows to request a xr persistent anchor\n *\nexport function useRequestXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => requestXRPersistentAnchor.bind(null, store), [store])\n}*/\n/**\n * hook that returns a function that allows to load a xr persistent anchor\n *\nexport function useLoadXRPersistentAnchor() {\n  const session = useXR((xr) => xr.session)\n  return useMemo(() => (session != null ? loadXRPersistentAnchor.bind(null, session) : undefined), [session])\n}*/\n/**\n * hook that returns a function that allows to delete a xr persistent anchor\n *\nexport function useDeleteXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => deleteXRPersistentAnchor.bind(null, store), [store])\n}*/\n/*\nexport function useXRPersistentAnchor(\n  id: string,\n): [anchor: XRAnchor | undefined, createAnchor: (options: XRAnchorOptions) => Promise<XRAnchor | undefined>] {\n  const cleanup = useRef<(() => void) | undefined>(() => {})\n  const store = useXRStore()\n  const session = useXR((xr) => xr.session)\n  const [anchor, setAnchor] = useState<XRAnchor | undefined>(undefined)\n  useEffect(() => {\n    if (session == null) {\n      return\n    }\n    cleanup.current?.()\n    cleanup.current = undefined\n    let cancelled = false\n    cleanup.current = () => (cancelled = true)\n    loadXRPersistentAnchor(session, id).then((anchor) => {\n      if (cancelled) {\n        anchor?.delete()\n        return\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n    })\n    return () => {\n      cleanup.current?.()\n      cleanup.current = undefined\n    }\n  }, [session, id])\n  const create = useCallback(\n    async (options: XRAnchorOptions) => {\n      await deleteXRPersistentAnchor(store, id)\n      cleanup.current?.()\n      cleanup.current = undefined\n      const abortRef = { current: false }\n      cleanup.current = () => (abortRef.current = true)\n      const anchor = await requestXRPersistentAnchor(store, id, options, abortRef)\n      if (abortRef.current) {\n        anchor?.delete()\n        return undefined\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n      return anchor\n    },\n    [id, store],\n  )\n  return [anchor, create]\n}*/\n/**\n * hook for requesting and storing a single xr anchor\n */\nexport function useXRAnchor() {\n    const [anchor, setAnchor] = useState(undefined);\n    const cleanup = useRef(() => { });\n    const store = useXRStore();\n    const create = useCallback(async (options) => {\n        cleanup.current?.();\n        cleanup.current = undefined;\n        let cancelled = false;\n        cleanup.current = () => (cancelled = true);\n        const anchor = await requestXRAnchor(store, options);\n        if (cancelled) {\n            anchor?.delete();\n            return undefined;\n        }\n        cleanup.current = () => anchor?.delete();\n        setAnchor(anchor);\n        return anchor;\n    }, [store]);\n    useEffect(() => () => void cleanup.current?.(), []);\n    return [anchor, create];\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useEffect, useMemo } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport tunnel from 'tunnel-rat';\nimport { useXR } from './xr.js';\n/**\n * Renders html elements as an overlay for handheld AR experiences\n * @param props Props are forwarded to a `div` element\n * @function\n */\nexport const XRDomOverlay = forwardRef((props, ref) => {\n    const domOverlayRoot = useXR((xr) => xr.domOverlayRoot);\n    const { In, Out } = useMemo(tunnel, []);\n    useEffect(() => {\n        if (domOverlayRoot == null) {\n            return;\n        }\n        const root = createRoot(domOverlayRoot);\n        root.render(_jsx(Out, {}));\n        return () => root.unmount();\n    }, [domOverlayRoot, Out]);\n    return (_jsx(In, { children: _jsx(\"div\", { ...props, ref: ref }) }));\n});\n", "import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { forwardObjectEvents } from '@pmndrs/pointer-events';\nimport { createXRLayer, createXRLayerGeometry, createXRLayerRenderTarget, getXRLayerSrcTexture, setupXRImageLayer, setXRLayerRenderTarget, updateXRLayerProperties, updateXRLayerTransform, waitForXRLayerSrcSize, } from '@pmndrs/xr';\nimport { addEffect, context, reconciler, useFrame, useStore, useThree, } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { OrthographicCamera, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3, Vector4, WebGLRenderTarget, } from 'three';\nimport { create } from 'zustand';\nimport { useXRSessionFeatureEnabled } from './hooks.js';\nimport { useXR, useXRStore } from './xr.js';\n/**\n * Component for rendering high quality quad, cylinder, or equirect layers inside supported sessions. Also includes a fallback for non-supported sessions.\n *\n * @param props\n * #### `src` - Property for displaying images and videos onto the layer. For rendering dynamic content to the layer, leave the `src` empty and put the dynamic (3D) content into the children, so that the layer acts as a render target.\n * #### `shape` - Property to configure the shape of the layer (\"quad\", \"cylinder\", \"equirect\").\n * #### `layout` - Property to configure the layout of the display content for stereo content (\"default\", \"mono\", \"stereo-left-right\", \"stereo-top-bottom\").\n * #### `centralAngle` - Property to configure the central angle in case the layer shape is a \"cylinder\".\n * #### `centralHorizontalAngle` - Property to configure the central horizontal angle in case the layer shape is \"equirect\".\n * #### `upperVerticalAngle` - Property to configure the upper vertical angle in case the layer shape is \"equirect\".\n * #### `lowerVerticalAngle` - Property to configure the lower vertical angle in case the layer shape is \"equirect\".\n * #### `chromaticAberrationCorrection` - Property to configure whether chromatic abberration should be corrected by the layer.\n * #### `quality` - Property to configure for what type of content the layer should be optimized (\"default\", \"text-optimized\", \"graphics-optimized\").\n */\nexport const XRLayer = forwardRef(function XRLayer({ src, pixelWidth = 1024, pixelHeight = 1024, dpr = 1, renderPriority = 0, children, customRender, ...props }, forwardedRef) {\n    const [hasSize, setHasSize] = useState(false);\n    const ref = useRef(null);\n    const renderTargetRef = useRef(undefined);\n    const layerEntryRef = useRef(undefined);\n    useEffect(() => {\n        setHasSize(false);\n        let aborted = false;\n        waitForXRLayerSrcSize(src).then(() => !aborted && setHasSize(true));\n        return () => void (aborted = true);\n    }, [src]);\n    const layersEnabled = useXRSessionFeatureEnabled('layers');\n    const geometry = useMemo(() => createXRLayerGeometry(props.shape ?? 'quad', {\n        centralAngle: props.centralAngle,\n        centralHorizontalAngle: props.centralHorizontalAngle,\n        lowerVerticalAngle: props.lowerVerticalAngle,\n        upperVerticalAngle: props.upperVerticalAngle,\n    }), [props.centralAngle, props.centralHorizontalAngle, props.lowerVerticalAngle, props.shape, props.upperVerticalAngle]);\n    const store = useLayerStore(pixelWidth, pixelHeight, dpr);\n    useForwardEvents(store, ref, [hasSize, layersEnabled]);\n    // hasSize and layersEnabled are deps because ref.current is only populated after children render\n    useImperativeHandle(forwardedRef, () => ref.current, [hasSize, layersEnabled]);\n    if (!hasSize) {\n        return null;\n    }\n    return (_jsxs(_Fragment, { children: [src == null && (_jsx(ChildrenToRenderTarget, { customRender: customRender, store: store, renderPriority: renderPriority, renderTargetRef: renderTargetRef, layerEntryRef: layersEnabled ? layerEntryRef : undefined, children: children })), layersEnabled ? (_jsx(XRLayerImplementation, { renderTargetRef: renderTargetRef, layerEntryRef: layerEntryRef, pixelWidth: pixelWidth, pixelHeight: pixelHeight, dpr: dpr, ref: ref, ...props, src: src, geometry: geometry })) : (_jsx(FallbackXRLayerImplementation, { renderTargetRef: renderTargetRef, ref: ref, ...props, src: src, pixelWidth: pixelWidth, pixelHeight: pixelHeight, dpr: dpr, geometry: geometry }))] }));\n});\nexport const XRLayerImplementation = forwardRef(({ src, shape, colorFormat, depthFormat, layout, mipLevels, renderOrder = 0, blendTextureSourceAlpha, centralAngle, centralHorizontalAngle, chromaticAberrationCorrection, lowerVerticalAngle, quality, upperVerticalAngle, invertStereo, pixelWidth, pixelHeight, dpr, renderTargetRef, layerEntryRef, ...props }, ref) => {\n    const internalRef = useRef(null);\n    const renderer = useThree((state) => state.gl);\n    const store = useXRStore();\n    const layerProperties = {\n        blendTextureSourceAlpha,\n        centralAngle,\n        centralHorizontalAngle,\n        chromaticAberrationCorrection,\n        lowerVerticalAngle,\n        quality,\n        upperVerticalAngle,\n    };\n    const layerPropertiesRef = useRef(layerProperties);\n    layerPropertiesRef.current = layerProperties;\n    const renderOrderRef = useRef(renderOrder);\n    renderOrderRef.current = renderOrder;\n    const originReferenceSpace = useXR((s) => s.originReferenceSpace);\n    //create layer\n    useEffect(() => {\n        if (internalRef.current == null || originReferenceSpace == null) {\n            return;\n        }\n        const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));\n        const layer = createXRLayer(resolvedSrc, store.getState(), originReferenceSpace, renderer.xr, internalRef.current, {\n            colorFormat,\n            depthFormat,\n            invertStereo,\n            layout,\n            mipLevels,\n            shape,\n        }, layerPropertiesRef.current);\n        if (layer == null) {\n            return;\n        }\n        const layerEntry = (layerEntryRef.current = {\n            layer,\n            renderOrder: renderOrderRef.current,\n            object3D: internalRef.current,\n        });\n        store.addLayerEntry(layerEntry);\n        if (resolvedSrc instanceof HTMLVideoElement || resolvedSrc instanceof WebGLRenderTarget) {\n            return () => {\n                store.removeLayerEntry(layerEntry);\n                layer.destroy();\n            };\n        }\n        const cleanupXRImageLayer = setupXRImageLayer(renderer, store, layer, resolvedSrc);\n        return () => {\n            store.removeLayerEntry(layerEntry);\n            cleanupXRImageLayer();\n            layer.destroy();\n        };\n    }, [\n        originReferenceSpace,\n        colorFormat,\n        depthFormat,\n        invertStereo,\n        layerEntryRef,\n        layout,\n        mipLevels,\n        pixelHeight,\n        pixelWidth,\n        dpr,\n        renderTargetRef,\n        renderer,\n        shape,\n        src,\n        store,\n    ]);\n    //update render order\n    if (layerEntryRef.current != null) {\n        layerEntryRef.current.renderOrder = renderOrder;\n    }\n    //update layer properties\n    if (layerEntryRef.current != null) {\n        updateXRLayerProperties(layerEntryRef.current.layer, layerPropertiesRef.current);\n    }\n    //update layer transform\n    useFrame(() => {\n        if (layerEntryRef.current == null || internalRef.current == null) {\n            return;\n        }\n        updateXRLayerTransform(store.getState(), layerEntryRef.current.layer, layerPropertiesRef.current.centralAngle, internalRef.current);\n    });\n    useImperativeHandle(ref, () => internalRef.current, []);\n    return (_jsx(\"mesh\", { ...props, renderOrder: -Infinity, ref: internalRef, children: _jsx(\"meshBasicMaterial\", { colorWrite: false }) }));\n});\nexport const FallbackXRLayerImplementation = forwardRef(({ src, renderTargetRef, dpr, renderOrder, pixelWidth, pixelHeight, ...props }, ref) => {\n    const materialRef = useRef(null);\n    useEffect(() => {\n        if (materialRef.current == null) {\n            return;\n        }\n        const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));\n        const texture = getXRLayerSrcTexture(resolvedSrc);\n        materialRef.current.map = texture;\n        materialRef.current.needsUpdate = true;\n        return () => {\n            if (resolvedSrc instanceof WebGLRenderTarget) {\n                resolvedSrc.dispose();\n                return;\n            }\n            texture.dispose();\n        };\n    }, [src, pixelWidth, pixelHeight, dpr, renderTargetRef]);\n    return (_jsx(\"mesh\", { ref: ref, ...props, children: _jsx(\"meshBasicMaterial\", { ref: materialRef, toneMapped: false }) }));\n});\nfunction useForwardEvents(store, ref, deps) {\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        let cleanup;\n        const update = (state, prevState) => {\n            if (state.camera === prevState?.camera && state.scene === prevState.scene) {\n                return;\n            }\n            cleanup?.();\n            const { destroy, update } = forwardObjectEvents(current, () => state.camera, state.scene);\n            const cleanupUpdate = addEffect(update);\n            cleanup = () => {\n                destroy();\n                cleanupUpdate();\n            };\n        };\n        update(store.getState());\n        const unsubscribe = store.subscribe(update);\n        return () => {\n            unsubscribe();\n            cleanup?.();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [store, ref, ...deps]);\n}\n// Keys that shouldn't be copied between R3F stores\nexport const privateKeys = [\n    'set',\n    'get',\n    'setSize',\n    'setFrameloop',\n    'setDpr',\n    'events',\n    'invalidate',\n    'advance',\n    'size',\n    'viewport',\n];\nexport function useLayerStore(width, height, dpr) {\n    const previousRoot = useStore();\n    const layerStore = useMemo(() => {\n        let previousState = previousRoot.getState();\n        // We have our own camera in here, separate from the main scene.\n        const camera = new PerspectiveCamera(50, 1, 0.1, 1000);\n        camera.position.set(0, 0, 5);\n        const pointer = new Vector2();\n        let ownState = {\n            events: { enabled: false, priority: 0 },\n            size: { width: 1, height: 1, left: 0, top: 0 },\n            camera,\n            scene: new Scene(),\n            raycaster: new Raycaster(),\n            pointer: pointer,\n            mouse: pointer,\n            previousRoot,\n        };\n        //we now merge in order previousState, injectState, ownState\n        const store = create((innerSet, get) => {\n            const merge = () => {\n                const result = {};\n                for (const key in previousState) {\n                    if (privateKeys.includes(key)) {\n                        continue;\n                    }\n                    result[key] = previousState[key];\n                }\n                return Object.assign(result, ownState, {\n                    events: { ...previousState.events, ...ownState.events },\n                    viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size)),\n                });\n            };\n            const update = () => innerSet(merge());\n            return {\n                ...previousState,\n                // Set and get refer to this root-state\n                set(newOwnState) {\n                    if (typeof newOwnState === 'function') {\n                        newOwnState = newOwnState(get());\n                    }\n                    Object.assign(ownState, newOwnState);\n                    update();\n                },\n                setPreviousState(prevState) {\n                    previousState = prevState;\n                    update();\n                },\n                get,\n                setEvents() { },\n                ...merge(),\n            };\n        });\n        return Object.assign(store, {\n            setState(state) {\n                store.getState().set(state);\n            },\n        });\n    }, [previousRoot]);\n    //syncing up previous store with the current store\n    useEffect(() => previousRoot.subscribe(layerStore.getState().setPreviousState), [previousRoot, layerStore]);\n    useEffect(() => {\n        const viewport = {\n            factor: 1,\n            distance: 0,\n            dpr,\n            initialDpr: dpr,\n            left: 0,\n            top: 0,\n            getCurrentViewport: () => viewport,\n            width,\n            height,\n            aspect: width / height,\n        };\n        layerStore.setState({\n            size: { width, height, top: 0, left: 0 },\n            viewport,\n        });\n    }, [width, height, dpr, layerStore, previousRoot]);\n    return layerStore;\n}\nconst v4Helper = new Vector4();\n//required hack to support pmndrs/postprocessing\nfunction getSize(target) {\n    this.getViewport(v4Helper);\n    target.x = v4Helper.z - v4Helper.x;\n    target.y = v4Helper.w - v4Helper.y;\n    return target;\n}\nconst viewportHelper = new Vector4();\nfunction ChildrenToRenderTarget({ renderPriority, children, layerEntryRef, renderTargetRef, store, customRender, }) {\n    useEffect(() => {\n        const update = (state, prevState) => {\n            const { size, camera } = state;\n            if (camera instanceof OrthographicCamera) {\n                camera.left = size.width / -2;\n                camera.right = size.width / 2;\n                camera.top = size.height / 2;\n                camera.bottom = size.height / -2;\n            }\n            else {\n                camera.aspect = size.width / size.height;\n            }\n            if (size !== prevState?.size || camera !== prevState.camera) {\n                camera.updateProjectionMatrix();\n                // https://github.com/pmndrs/react-three-fiber/issues/178\n                // Update matrix world since the renderer is a frame late\n                camera.updateMatrixWorld();\n            }\n        };\n        update(store.getState());\n        return store.subscribe(update);\n    }, [store]);\n    let oldAutoClear;\n    let oldXrEnabled;\n    let oldIsPresenting;\n    let oldRenderTarget;\n    let oldGetDrawingBufferSize;\n    let oldGetSize;\n    //TODO: support frameloop=\"demand\"\n    useFrame((_, delta, frame) => {\n        if (renderTargetRef.current == null ||\n            (layerEntryRef != null && (layerEntryRef.current == null || frame == null))) {\n            return;\n        }\n        const state = store.getState();\n        const { gl, scene, camera } = state;\n        oldAutoClear = gl.autoClear;\n        oldXrEnabled = gl.xr.enabled;\n        oldIsPresenting = gl.xr.isPresenting;\n        oldRenderTarget = gl.getRenderTarget();\n        oldGetSize = gl.getSize;\n        oldGetDrawingBufferSize = gl.getDrawingBufferSize;\n        gl.getViewport(viewportHelper);\n        gl.autoClear = true;\n        gl.xr.enabled = false;\n        gl.xr.isPresenting = false;\n        const renderTarget = renderTargetRef.current;\n        gl.setViewport(0, 0, renderTarget.width, renderTarget.height);\n        gl.getSize = getSize;\n        gl.getDrawingBufferSize = getSize;\n        setXRLayerRenderTarget(gl, renderTarget, layerEntryRef?.current, frame);\n        if (customRender != null) {\n            customRender(renderTarget, state, delta, frame);\n        }\n        else {\n            gl.render(scene, camera);\n        }\n        gl.setRenderTarget(oldRenderTarget);\n        gl.setViewport(viewportHelper);\n        gl.autoClear = oldAutoClear;\n        gl.xr.enabled = oldXrEnabled;\n        gl.xr.isPresenting = oldIsPresenting;\n        gl.getSize = oldGetSize;\n        gl.getDrawingBufferSize = oldGetDrawingBufferSize;\n    }, renderPriority);\n    return _jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: children }), store, null) });\n}\n", "import { createXRControllerLocomotionUpdate, } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { useMemo } from 'react';\nimport { useXRStore } from './xr.js';\n/**\n * A hook for handling basic locomotion in VR\n * @param target Either a `THREE.Group` ref, or a callback function. Recieves movement input (required).\n * @param translationOptions Options that control the translation of the user. Set to `false` to disable.\n *\n * #### `translationOptions.speed` - The speed at which the user moves.\n *\n * @param rotationOptions Options that control the rotation of the user. Set to `false` to disable.\n *\n * #### `rotationOptions.deadZone` - How far the joystick must be pushed to trigger a turn.\n * #### `rotationOptions.type` - Controls how rotation using the controller functions. Can be either 'smooth' or 'snap'.\n * #### `rotationOptions.degrees` - If `type` is 'snap', this specifies the number of degrees to snap the user's view by.\n * #### `rotationOptions.speed` - If `type` is 'smooth', this specifies the speed at which the user's view rotates.\n *\n * @param translationControllerHand Specifies which hand will control the movement. Can be either 'left' or 'right'.\n */\nexport function useXRControllerLocomotion(target, translationOptions = {}, rotationOptions = {}, translationControllerHand = 'left') {\n    const store = useXRStore();\n    const update = useMemo(() => createXRControllerLocomotionUpdate(), []);\n    useFrame((state, delta, frame) => update(typeof target === 'function' ? target : target.current, store, state.camera, delta, translationOptions, rotationOptions, translationControllerHand, delta, state, frame));\n}\n", "import { forwardHtmlEvents } from '@pmndrs/pointer-events';\nimport { addEffect, useThree } from '@react-three/fiber';\nimport { useEffect } from 'react';\nexport function PointerEvents({ batchEvents, clickThesholdMs, clickThresholdMs, contextMenuButton, customSort, dblClickThresholdMs, filter, forwardPointerCapture, intersectEveryFrame, pointerTypePrefix, }) {\n    const domElement = useThree((s) => s.gl.domElement);\n    const alwaysRendering = useThree((s) => s.frameloop === 'always');\n    const camera = useThree((s) => s.camera);\n    const scene = useThree((s) => s.scene);\n    useEffect(() => {\n        const { destroy, update } = forwardHtmlEvents(domElement, () => camera, scene, {\n            batchEvents: batchEvents ?? alwaysRendering,\n            clickThesholdMs,\n            clickThresholdMs,\n            contextMenuButton,\n            customSort,\n            dblClickThresholdMs,\n            filter,\n            forwardPointerCapture,\n            intersectEveryFrame,\n            pointerTypePrefix,\n        });\n        const cleanupUpdate = addEffect(update);\n        return () => {\n            cleanupUpdate();\n            destroy();\n        };\n    }, [\n        domElement,\n        camera,\n        scene,\n        alwaysRendering,\n        batchEvents,\n        clickThresholdMs,\n        clickThesholdMs,\n        contextMenuButton,\n        customSort,\n        dblClickThresholdMs,\n        filter,\n        forwardPointerCapture,\n        intersectEveryFrame,\n        pointerTypePrefix,\n    ]);\n    return null;\n}\nexport const noEvents = () => ({ enabled: false, priority: 0 });\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef } from 'react';\nimport { useStore } from 'zustand';\nimport { useXRSessionModeSupported } from '../hooks.js';\n/**\n * @deprecated use `<button onClick={() => store.enterXR()}>` instead\n */\nexport const XRButton = forwardRef(({ store, mode, onError, children, ...props }, ref) => {\n    const session = useStore(store, (xr) => xr.session);\n    const supported = useXRSessionModeSupported(mode, onError);\n    return (_jsx(\"button\", { ref: ref, ...props, onClick: () => (session != null ? session.end() : store.enterXR(mode).catch(onError)), children: typeof children === 'function'\n            ? children(supported ? (session != null ? 'entered' : 'exited') : 'unsupported')\n            : children }));\n});\n/**\n * @deprecated use `<button onClick={() => store.enterAR()}>` instead\n */\nexport const ARButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-ar\", ...props });\n});\n/**\n * @deprecated use `<button onClick={() => store.enterVR()}>` instead\n */\nexport const VRButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-vr\", ...props });\n});\n", "import { PointerEvent } from '@pmndrs/pointer-events';\nimport { useEffect, useRef } from 'react';\nimport { useXRInputSourceState, useXRInputSourceStateContext } from '../input.js';\nimport { useXRSpace } from '../space.js';\nimport { useXR } from '../xr.js';\nconst eventTranslations = {\n    onBlur: 'pointerleave',\n    onHover: 'pointerenter',\n    onMove: 'pointermove',\n    onSelect: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSqueeze: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'grab',\n    },\n};\n/**\n * @deprecated Use normal react-three/fiber event listeners instead (e.g. `<mesh onClick={...} />`)\n */\nexport function useInteraction(ref, type, handler) {\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const translation = eventTranslations[type];\n        const fn = typeof translation === 'string'\n            ? (event) => handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState })\n            : (event) => {\n                if (event instanceof PointerEvent && !translation.filter(event)) {\n                    return;\n                }\n                handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState });\n            };\n        const eventName = typeof translation === 'string' ? translation : translation.type;\n        current.addEventListener(eventName, fn);\n        return () => current.removeEventListener(eventName, fn);\n    }, [ref, type]);\n}\n/**\n * @deprecated Implement custom listeners instead\n */\nexport function useXREvent(type, handler, { handedness } = {}) {\n    const session = useXR((xr) => xr.session);\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        const fn = (e) => {\n            handlerRef.current?.({\n                type: e.type,\n                data: e.inputSource,\n            });\n        };\n        session.addEventListener(type, fn);\n        return () => session.removeEventListener(type, fn);\n    }, [session, handedness, type]);\n}\nexport function useXRTransientPointerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('transientPointer')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('transientPointer', handedness);\n}\n/**\n * Hook for getting the gaze state\n *\n * @deprecated use `useXRInputSourceStateContext(\"gaze\")` instead\n */\nexport function useXRGazeState() {\n    return useXRInputSourceStateContext('gaze');\n}\n/**\n * Hook for getting the screen-input state\n *\n * @deprecated `useXRInputSourceStateContext(\"screenInput\")` instead\n */\nexport function useXRScreenInputState() {\n    return useXRInputSourceStateContext('screenInput');\n}\nexport function useXRHandState(handedness) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return handedness == null ? useXRInputSourceStateContext('hand') : useXRInputSourceState('hand', handedness);\n}\nexport function useXRControllerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('controller')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('controller', handedness);\n}\n/**\n * @deprecated use `useXRSpace` instead\n */\nexport const useXRReferenceSpace = useXRSpace;\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useRef } from 'react';\nimport { useInteraction } from './hooks.js';\n/**\n * @deprecated Just use `<group onClick... />`\n */\nexport const Interactive = forwardRef(({ onHover, onBlur, onSelectStart, onSelectEnd, onSelect, onSqueezeStart, onSqueezeEnd, onSqueeze, onMove, children, }, passedRef) => {\n    const ref = useRef(null);\n    useImperativeHandle(passedRef, () => ref.current);\n    useInteraction(ref, 'onHover', onHover);\n    useInteraction(ref, 'onBlur', onBlur);\n    useInteraction(ref, 'onSelectStart', onSelectStart);\n    useInteraction(ref, 'onSelectEnd', onSelectEnd);\n    //useInteraction(ref, 'onSelectMissed', onSelectMissed)\n    useInteraction(ref, 'onSelect', onSelect);\n    useInteraction(ref, 'onSqueezeStart', onSqueezeStart);\n    useInteraction(ref, 'onSqueezeEnd', onSqueezeEnd);\n    //useInteraction(ref, 'onSqueezeMissed', onSqueezeMissed)\n    useInteraction(ref, 'onSqueeze', onSqueeze);\n    useInteraction(ref, 'onMove', onMove);\n    return _jsx(\"group\", { ref: ref, children: children });\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { isXRInputSourceState } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';\nimport { Matrix4 } from 'three';\nimport { Interactive } from './interactive.js';\n/**\n * @deprecated use `DragControls` instead\n */\nexport const RayGrab = forwardRef(function RayGrab({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {\n    const grabbingController = useRef(undefined);\n    const groupRef = useRef(null);\n    const previousTransform = useMemo(() => new Matrix4(), []);\n    useImperativeHandle(forwardedRef, () => groupRef.current);\n    useFrame(() => {\n        const controller = grabbingController.current;\n        const group = groupRef.current;\n        if (!group || !controller)\n            return;\n        group.applyMatrix4(previousTransform);\n        controller.updateWorldMatrix(true, false);\n        group.applyMatrix4(controller.matrixWorld);\n        group.updateMatrixWorld();\n        previousTransform.copy(controller.matrixWorld).invert();\n    });\n    return (_jsx(Interactive, { ref: groupRef, onSelectStart: (e) => {\n            if (isXRInputSourceState(e.target) &&\n                (e.target.type === 'controller' || e.target.type === 'hand') &&\n                e.target.object != null) {\n                grabbingController.current = e.target.object;\n                e.target.object.updateWorldMatrix(true, false);\n                previousTransform.copy(e.target.object.matrixWorld).invert();\n                onSelectStart?.(e);\n            }\n        }, onSelectEnd: (e) => {\n            if (e.target.controller === grabbingController.current) {\n                grabbingController.current = undefined;\n            }\n            onSelectEnd?.(e);\n        }, ...rest, children: children }));\n});\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "i", "i", "self", "res", "joints", "clone", "URL", "sourceURI", "node", "accessor", "i", "clone", "i", "i", "event", "i", "quaternionHelper", "emulate", "i", "_a", "i", "matrixHelper", "vectorHelper", "quaternionHelper", "context", "quaternionHelper", "i", "matrixHelper", "vectorHelper", "scaleHelper", "quaternionHelper", "matrixHelper2", "quaternionHelper", "positionHelper", "vectorHelper", "vectorHelper", "quaternionHelper", "eulerHelper", "positionHelper", "scaleHelper", "i", "import_react", "import_react", "import_jsx_runtime", "import_react", "createStoreImpl", "createStore", "import_react", "ReactExports", "useSyncExternalStoreExports", "useStore", "createStore", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "import_react", "state", "XRControllerModel", "_jsx", "XRSpace", "import_jsx_runtime", "import_react", "XRHandModel", "_jsx", "XRSpace", "import_jsx_runtime", "import_react", "CombinedPointer", "_jsx", "PointerRayModel", "PointerCursorModel", "_jsxs", "_Fragment", "import_jsx_runtime", "import_react", "_jsx", "TeleportPointerRayModel", "_jsx", "XRSpace", "PointerCursorModel", "_jsxs", "PointerRayModel", "_Fragment", "XRControllerModel", "CombinedPointer", "XRHandModel", "state", "TeleportPointerRayModel", "import_react", "map", "_jsx", "_Fragment", "_jsxs", "XRSpace", "spreadable", "createXRStore", "_jsx", "_jsxs", "useStore", "XRSpace", "_jsx", "context", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "useStore", "_jsx", "import_react", "create", "anchor", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "XRLayer", "_jsxs", "_Fragment", "_jsx", "update", "import_react", "import_react", "import_jsx_runtime", "import_react", "useStore", "_jsx", "import_react", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "RayGrab", "_jsx"]
}
